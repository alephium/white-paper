<TeXmacs|1.99.5>

<style|article>

<\body>
  <doc-data|<doc-title|Alephium: a scalable cryptocurrency system based on
  blockflow>|<doc-author|<\author-data|<author-name|Cheng Wang [Version
  0.1]>|<\author-affiliation>
    <hlink|www.alephium.org|http://www.alephium.org>
  </author-affiliation>>
    \;
  </author-data>>>

  <abstract-data|<\abstract>
    Since Bitcoin's success as the first widely used digital currency,
    cryptocurrency has attracted tons of attention. Although there are
    thousands of different digital currencies existing nowadays, many open
    problems and challenges are still remaining. Particularly, the
    scalability issue is of great importance in the field of cryptocurrency.
    We propose a new cryptocurrency system aiming to solve this critical
    issue.

    Firstly, we propose a novel sharding algorithm supporting native
    cross-shard transactions that would improve the system throughput
    dramatically. We call our new technology blockflow, as an improvement of
    the well-known blockchain technology. With blockflow, it is possible to
    handle a thousand times of the transaction throughputs compared to
    traditional blockchain algorithms.

    Secondly, we decompose smart contract into token protocol and data
    protocol to enable developers to build scalable blockchain applications
    easily. With our new protocol, application data and computation could be
    either totally decentralized or partly centralized. Developers have the
    flexibility to choose the tradeoff that matches the best their specific
    scenario.

    In this paper, we also introduce our new decentralized cryptocurrency
    system Alephium based on blockflow and our protocols.
  </abstract>|<abstract-keywords|cryptocurrency, blockchain, blockflow,
  scalability>>

  <section|Introduction><label|sec-intro>

  Currently, all the blockchain protocols based on Proof-of-Work (PoW) system
  can not process more transactions than a single node could. In practice,
  Bitcoin <cite|nakamoto2008bitcoin> and Ethereum <cite|buterin2014next> can
  handle <math|\<less\>20> transactions per second. However, VISA could
  handle on average thousands of transactions per second (TPS). If we want to
  use cryptocurrency for all kinds of transactions world-widely, we would
  like to scale our decentralized protocol to handle at least thousands of
  TPS as well. This is usually related to the well-known scalability problem
  of cryptocurrency. If one wants to build a decentralized exchange
  application, the scalability problem must be solved to a certain level. In
  the paper, we will introduce a new cryptocurrency system that is scalable
  by using a novel sharding algorithm.

  Our algorithm stands somewhere between blockchain algorithms and DAG
  algorithms. DAG algorithms for cryptocurrency usually have security issues
  as it's especially hard to reach dependency consistency among participants
  while ensuring reasonable scalability, e.g. IOTA <cite|popov2018tangle>
  only works with probability or relies on a centralized coordinator at the
  time of writing. Our algorithm uses a scalable UTXO model to achieve
  scalability and consensus at the same time. In our algorithm, there are a
  number of parallel chains. Each chain is a group of transactions with
  certain requirements. All these parallel chains are dependent on each
  other. We design an algorithm to resolve the dependencies among all chains
  and to add new blocks onto these chains. Nodes in our system only need to
  keep part of the transactions of these chains, which contributes to
  scalability.

  Another challenge of sharding algorithms is the design of smart contracts.
  First of all, we agree that smart contracts are very useful and result in
  many useful applications. However, like evolving from single threading
  programming to multithreading programming, scaling smart contract to work
  with multiple shards would rely on locks or methods similar to locks which
  would make applications complicated and inefficient. We propose a practical
  solution to this issue by decomposing contracts into a token part and a
  data part. We designed several typical types of tokens and a scripting
  language for programming at the level of tokens. Another problem we found
  is that currently the models and the scripting languages designed for smart
  contracts are tightly coupled with the cryptocurrency system. This makes
  the contract language very hard to design, upgrade and run safely on chain.
  Experience in programming language design reminds us that it's better to
  have different domain-specific languages for different scenarios. In our
  system, we separate our underlying protocol from the concrete computation
  model. We achieve this by only caring about data at the protocol level.
  Then third parties can provide their custom interpreter to parse the data.
  In this sense, it is very similar to the TCP/IP protocol.

  The rest of the paper is organized as follows. In Section
  <reference|sec-blockflow>, we introduce and discuss our new blockflow
  algorithm. In Section <reference|sec-exchange>, we introduce and discuss
  our protocols and applications. In Section <reference|sec-alephium>, we
  provide a high-level description of Alephium system. We discuss future
  researches in Section <reference|sec-conclusion>.

  <section|Blockflow><label|sec-blockflow>

  Ideally, for a currency system, we only need to care about the flow of
  currency among all the participants. If we use the unspent transaction
  output (UTXO) model like bitcoin where each transaction is a pair of inputs
  and outputs, then we only need to maintain the dependencies of transactions
  such that all the inputs and outputs match. A transaction <math|t<rsub|1>>
  depends on transaction <math|t<rsub|2>> if one of the inputs of
  <math|t<rsub|1>> depends on one of the outputs of <math|t<rsub|2>>. All the
  transactions with such dependencies form a directed acyclic graph (DAG)
  with transactions as nodes and dependencies as edges. We call such graph
  transaction flow, inspired by network flow.

  However, transaction flow is not a proper model for decentralized currency
  systems. The main problem is that usually there are a lot of UTXOs (unspent
  transaction output) in the system. Each UTXO does not have a successor in
  the flow graph, which would cause the UTXO to be altered by attackers
  easily. In blockchain technology, especially single chain approach, such
  transaction flow is flattened into one single chain of transactions so that
  every transaction would have output dependencies. While such as system is
  simple to implement and easy to prove safe, it suffers from the drawback of
  introducing too many unnecessary dependencies on transactions. It is
  forcing a total ordering on all transactions, while in fact they only form
  a partial ordering. The main drawback of totally ordered transactions is
  that they discourage parallel-transaction confirmation, which decreases the
  throughput and increases the latency of the whole system.

  We propose a new consensus algorithm called <em|BlockFlow> to attack the
  scalability problem of blockchain. In our approach, all the users are
  divided into <math|G> separated groups. For each <math|i,j\<in\>G>, there
  is a transaction shard which consists of all the transactions from group
  <math|i> to group <math|j>. Therefore, there are <math|G\<times\>G>
  transaction shards in total. In our cryptocurrency system, we require that
  each transaction shard should be constructed as one blockchain so that all
  the transactions in the same transaction shard would be totally ordered.
  Transactions in different transaction shards could be committed in parallel
  as long as the order does not violate all the basic dependencies in the
  transaction-flow graph. We use PoW to reach finality for all shards in this
  paper, but any other finality algorithm could be adjusted to work with
  BlockFlow.

  <subparagraph|Scalable UTXO model.>There is an issue to apply the
  conventional UTXO transaction model with our transaction sharding
  mechanism. Let us check out the following simple example. Suppose Alice (of
  Address <math|i>) has a UTXO with <math|100> coins. She wants to send
  <math|90> coins to Bob (of Address j). This would result in two new UTXOs:
  one for Bob and another one for Alice containing the rest coins. If Alice
  is from group <math|i> and Bob is from group <math|j>, then this one
  transaction contains both transactions from group <math|i> to group
  <math|j> and from group <math|i> to group <math|i>. Therefore, we cannot
  put this transaction in any single transaction shard.

  <tabular*|<tformat|<twith|table-width|1par>|<twith|table-hmode|exact>|<table|<row|<cell|<image|<tuple|<#89504E470D0A1A0A0000000D49484452000008D7000001EB0800000000C31AB64E0000000467414D410000B18F0BFC6105000000206348524D00007A26000080840000FA00000080E8000075300000EA6000003A98000017709CBA513C00000002624B474400FF878FCCBF000000097048597300002E2300002E230178A53F760000000774494D4507E2051D081D36C30EB82600004BB44944415478DAEDDDCF8ADBC802FE7D5F86AEC29BBE05D3B7107403816CBCCAAA775A07B2F12AC96E40D0309B1F644CF3C221FC78E3813730D0E0B3EC85189866C0E164114C134619FCAAAA54529524BB2D77B95592BE1F3867D2B6AC9693D6D34FE94F79B2030000188649D71B000000E008BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD0600000C05BD06FEFBFE75FD051EBBFBFAA3EB9F11A08ADCF0DCD972835E03CF7DFF14BD84F7A24FDFBBFE49014AE4462F9C2737E835F0DB97AE773C1CEBC3D7AE7F58801CB9D11B67C80D7A0D7CF6E36DD73B1D5AF8F8B3EB1F1860476EF48CF3DCA0D7C0637FBD563FF71FAEBB3E138C433EE85F236F391985EE911BFD70B6DCA0D7C05F6BF933FF7ACD5100EFFDB8535733BCA6D8A06BE4466F9C2937E835F0D60F39EA7ACBAD36FD70F79A62030F901BBD728EDCA0D7C05BD7E2E7FD53D75B8163FDFC20038A51323A456EF4CB1972835E035F7D153FED5FBADE0AB4F0515E04D8F55660D4C88DDE719E1BF41A78EAA738F11A31F8EF153954E6766F7487DCE821D7B941AF81A7D6FC8AEC9F9FE25CF9DBAEB70223466EF490EBDCA0D7C053A2C25F77BD1168E92FF15B852B36D11972A38F1CE706BD069E123FE8DC5BD33B6FB9B8015D22377AC96D6ED06BE02771F5DFEBAE3702AD89D3001FBADE088C16B9D14F6E73835E033F7DE5F7632F7DE7F70A3A446EF493DBDCA0D7C04F5FB863B89FC47980AEB701A3456EF494D3DCA0D7C04F5FB84EA39F5E737D03BA436EF494D3DCA0D7C04FE4534F7DE0365B7487DCE829A7B941AF819FC8A79EA2D7A043E4464FD16B3002E4534FD16BD02172A3A7E8351801F2A9A7E835E810B9D153F41A8C00F9D453F41A7488DCE8297A0D46A037F9F4705F7AB01ED87DBB6F96EEECAFCA05CD15A7F7F7B737F7F7DFBA7E832DD16BD0217283DCA0D7C057BDC9A79B8BD28DF5C0EEEAA2D9FDCEFEAA5CB0586B7AFDA258E0EAFEE48DEB00BD061D2237C80D7A0D7CD59B7CBABFCED3E5C5D5CD7DFE40962D2FDEDC1CC8A79B372F8A176583B5DBEBAB4BF592DCE74BF9ECAB2BF5DFAB87AEDFE5F1E835E810B9416ED06BE0ABDEE4D34E0F9BEECA073ECBD154F6F87B75C0F84A0FB0C48164F587FCB137F92BBE656194EA977F7B25C3E94E3CF0EDA61CD1F502BD061D2237C80D7A0D7CD5BF7C3222E446E7D38DB9407E5838FFC3C385916AE9E5C56579425C8EC92E1FCA95656EBB7E93C7A2D7A043E406B941AF81AF86914F77E602763EE5B97329475BAFCC619B7AA28CABF7E5723D40AF4187C88DE2EB11E706BD067E1A463EDD9B0B145FE47F78551C517E6FBEFAC13AD0BC93C79A33EFBB7E9747A2D7A043E44661C4B941AF819FFA974F9FCB078ECBA76FFA6AC0CF561CBDA9AE4D1D5FBEE8C98D9BF41A7488DC288D3737E835F053FFF2C9B8ABF2C6FAAA6101E55ADDDA7097FDCF385AAC52CBBC93E17D9F2E01A4D7A043E44669BCB941AF819F7A9D4F77C7E553AAE79A30AEFDDBDDAB87CCE5D489F3ABAEDFE671E835E810B9511A6F6ED06BE0A75EE7D3FD71F9A4B3C8BA69E1B34AAC86C5BA7E9BC7A1D7A043E4466DB1AEDFE671E835188151E4933EA26CDEB3D030C81A6F3E01ED901BD6EA469A1BF41AF8691CF994AA7941AF8D87C827E064E486B5BA91E606BD067E1A473EE5478F2BD70EDAB76B8E399F8076C80D6B7523CD0D7A0DFC348E7CD25700BE2A1F6A98FF7CBCF904B4436E58AB1B696ED06BE0A771E453F10977651EDDD4971D6F3E01ED901BD6EA469A1BF41AF8A9D7F974E4FD9A228BDEDFA9F029EED8546164CD7E7EABAE12ECFA6D1E875E830E911BA5F1E606BD067EEA533E5D570F01DFD8F363EDCBA73BF961BC6FEC23CA69E5F8F24E0FC57A32213ABD061D2237ACD58D3437E835F0539FF2E9B67A73C275E5E06F733E3D5CCA0FDFCDEF6D2826407F55B9D141BFFCB6EBB7791C7A0D3A446E545F7EDBF5DB3C0EBD0623D0A77C521FD8624C89755999E4B3319FD257F943EADE864B3D52136977672D599FACC263F41A7488DC288D3737E835F0539FF229FF68965BFDE56DF5E06F633EBD2FC65A57F6D4135795D3E4EA4CFADDAE1FE835E810B95118716ED06BE0A75EE5933A51AE3FADE5DB65358B9AF2C908B107FB88F237FB764DF5EC9B5D4FD06BD0217263673D3BCEDCA0D7C04FBDCA27796E3B0BA8DB872C4EEE2EABE7B99BF2E99BBCF62F971F51D65FDF18B739C8C3CEC6D166EFD16BD021722337EADCA0D7C04FFDCAA77CE494E588FCC32BF378F0B7FBCF6A16ADF7F74542DD7FCE96BBD15F7EBB532FBFBACB63E9F6F2E2EAE6FEFEFEE1DBE7376AD4D59B78A2D7A04BE406B941AF81AFFA954FBBF446275496519FCD678A29B48C39B2AEAC2FCD25F203C9E9B5F9A217F7ADB6A55BF41A7488DC2037E835F055CFF2298B94CF376FAE2E5E5DDD7CB66F40B8BE32551EAB2D71AB5FF6F0F98D3A907C75DD972BFF147A0D3A446E901BF41AF8AA77F904855E830E911B3D45AFC108904F3D45AF4187C88D9EA2D76004C8A79EA2D7A043E4464FD16B3002E4534FD16BD02172A3A7E8351801F2A9A7E835E810B9D153F41A8C00F9D453F41A7488DCE8297A0D46807CEA297A0D3A446EF414BD0623403EF514BD061D22377A8A5E8311209F7A8A5E830E911B3D45AFC108904F3D45AF4187C88D9EA2D76004C8A79EA2D7A043E4464FD16B3002E4534FD16BD02172A3A7E8351801F2A9A7E835E810B9D153F41A8C00F9D453F41A7488DCE8297A0D46807CEA297A0D3A446EF414BD0623403EF514BD061D22377ACAFF5EF3D7974F1FE0B32F5FBE3FDF0FEC69C8A79E3A3D9FC80DDF911B3817CF7BCDF78FAF5FC27FD1A79FCFFA63DB16F9D45327E613B9D10FE406CEC2EF5EB3269DFA22F2FA6C01F9D453A7E513B9D11BE406CEC0E75EF3F3BAEB9D0E2DF8BCFF934F3D754A3E911BBDE2F37E496EF494C7BDE66B247FEC5F7FFCF2D757F8EBEE4BFE7BE4C38F67FFF13D16F9D45327E413B9D10FE406CEC6DF5EF3E3B5F76D1EB97C84FCB6EBEDD88B7CEAA9F6F9446EF407B981F3F0B7D7882D7B19797FC53CA4BBD75EFF32219F7AAA7D3E911B7D426EE01CBCED357F899FF76BBFAF9647E9FB5B71ECDFD723CAE4534FB5CE2772A35FC80D9C81AFBDE6A738491E75F13782D3FC90BF50BADE8A3DC8A79E6A9B4FE446DF901B70CFD75EF3E9A5CB0DC3331019F0F2AFAEB762FFB6914F3DD4369FC88DDE2137E09CAFBD46FCAC7FECE22F04271343E50F5D6F4433F2A9A7DAE613B9D13FE4065CF3B4D788B3E4AF3949DE2F5FC52F153FFFD1C8A79E6A994FE4460F911B70CDD35EF38961570F45DE1E50FED2F5E463385D8B7C2237FA88DCC01978D86B44DDBAEBE42719A7FBF8D2D7D10DF9D4632DF289DCE823720367E061AF79EB72B3F04C440A7CEA7A23F66E197AAA4510901B7D446EE00C3CEC3562B3FC3CE38AFDC4D50D7E5E00C879F29E6A799E9CDCE82372038E797A7D8DC8A74EFE3EF0045FC927B87542AFE97A93D116B901C7E83570867C8263F49A112037E018BD06CE904F708C5E3302E4061CA3D7C019F2098ED16B4680DC8063F41A38433EC1317ACD08901B708C5E0367C8273846AF190172038ED16B9EE6C6603D70FF70D3EC76776F7DB52B16BC37D67BFFF9E6E6EAFDCDCDDD43D7EFB005F2098E0DB5D7901B0672038ED16B9EE6C2603D70737FD1EC6A77637DB52B16BCD12B4DCD255EDD9FBC71CF8D7C826343ED35E48681DC8063F49AA7B9FFFC46A6C8E5CDED7DFEC0CD65F6D5DD431E3B9757AFF2FF5E5DBD5089F47077F3224FA4DB6F591AC9755C9643ACDB4BF9823737D7EAA56FFA32F6229FE0D8507B0DB9612037E018BDE6A9540EBD301E91A329F1B8B9C095FAE246FDE14146D045FE5136699643DFF4ABD32B994E2AEDD2F7F28BDBAEDFE471C8273836D45E436E18C80D3846AF79AA7BE360B272443EE5C7942F53F94536ECBA2D5EAD9E29BE7E652CE73BF249DA26C2C67C68231FDA76FDD7D08EDCE6E4C81FBD6D9B858F37F45E436EECC69E1B0DD9D06ACFF3574310EE97B659F851F49AA7DA9F4F57E602F9179FF51FF243C5E28F5922BD2F5EFCCD3E65BE4B5F14CB796FDCF9545805934C683EB4108F4CE28EFF165AF6AA99DCE8E4C837DD66E1E38DB1D7901BDE788EDC88EAD9303DCFCEF474EDAA96CA84F0B88537418B851F45AF79AA76F9543CAA72481C51BEBDB87855BE581E4DBE30CE8CCB23CA17BDB8087054F9B4C9F6C2E9BE27A3DA1E9ACE5CF69A68121E1AD96C17E174328D56C632E92ACAD2328CF7BF2CC9DED0ACB29E36E9DA6AE163D16BF417E44607DCE54674605CB3AD67C3C6E5CEB40D2791D94892F0D1752FE7A1480B73B14D9C3D345BACF7771B51C7EC7C11A9777455110B2F1CBD657ACD53ED3B4FFEEDEADA5C40C7927E343F6EFC22FD76691E2EBEABAD4D3DF26AD70363C8A7C2E2D0902AAEEFCEA1C35EB3CEBE75B4FFE9580C7D42F17F4BFD90C80CF5D06ADFABE4B8B1527B5AA52BBDA60D72A33086DC080E0D831AB2C1E5CE24A26A5D7CB58D1E5D7722D262266ACAACF81113075FA6D343C1230646D56212B63904E33022E9354F65C58F647FD5B080A40E145FBC7F610DAAAEE583D7E6726A80D68793AD63C8A7823C6CBA6F1F3F73AF591DEC3571DE5E56B3B2C5CCB3C4D9EED265B03FD2828658A2D79C0DB95118416EAC0F9E593A73AF898C5E93CA41CFE1756FB345C4019ECDBC2C3659E4CCD6F250CFDEE49103A3A0F6CEE835A55EE7D3D551F954CE3FF1D97AAD7D9A3C63DD02E1B511E453613D9906B5BDB870E65E93AD6CBAF76219914AAACE24459E2DF4F664F11434BF723599D563895E7336E4466104B911C9BD6B5F233873AFD94E8B3412D7FECD1E5B775667E6EA4F53BDCD224A646EA4C1DE1C0BE49AD7D663F41ACB18F2291F6319D7FEEDF4F45CB73B6B75B5C8F2D408F2A9104DE268FF599D73F79A4317F045E501EF5007547998666A9C9CB2CC27CBA8164BF49AB321370AC3CF8D346B0507864167EE35655C2493D9729B3CB2EE4D1903E2C0B07C6D5494B278DFF9B46C60248E4ACDABEF8C5E531A453EE54794CD83C7793E5957FB914F4FE7BCD788A04A6A7B71E1ECBDE600E3EA3B9133F97FC3F2A159D3ABC41BAAC712BDE66CC88DC2F07323FB9DBF3B300C3A7BAFD15271CCE5B15EB3CC5323DF0CB9CDD3FC708D7AA8F1E6836C6024CF655B432E7A8D6514F9945FDA67A511F9D4DEAFFFFDFED822CE7B8D082A79FD7FF3499D2E7B8D71E3851E7995A3ADF28072C552349A5A2CD16BCE86DC280C3F37C2AC1DACF70F839EADD7488FF51AF366CEFC88EFC6A83AB3E623BE626024AF50B69EA4D758C6914FE965C33D1195DB35C9A747BD7BF7EE973FFE777011E7BD2614BB6F6D2FCEFE4997D96E1F84E6ED8DDB45D67FA6E154EEB4DB58C81E4D16B3443E1BCFA7817143651285E1345C2CF5EAC2309CCD63EBEC905A47FE8A643EB74F1D25E6B0303FA76F9E139F34C7D24CBCA836A4341370B50827B368297BCF4A6CC1365984C16CB14ACD85937811CE939D2BF49A8697921B4E3C5F6E6CE570A16118B459046536286BB113CEE66ACF5BE57BBA98A5413EBB8AB35D6E1EEBD554F261B3C8BE0AA3D81A9B24322E8C6F6CF79A340EEDE5776678CDD5C933F3E4D3BCB9AAACC4A39BEA5C1166AF49E2703A9DAB9926E44625D9E64F83F9725B2E1C8B749B57B7A83D7ACD533D219FDEE717001AD923BFBEB496229F1EF14EFAE5F7BFFFDDBB88EB5EA382AA36854D3A9F14F2DD79332B1FCAB22B95536EEDD6D33C5BD41C7EC521966DA897955F16CF5A41B209CB17A4B5432C89595CA6EAA5665D69BEEEAF7C43562C950998EA2D9B891492336E4DF52369B1F0227FB70767D769835ED3F05272C389E7CB0D7930B43E0C5ACB2BF5CDFD7F174FCB8792FC36AA45BAC813218DF25D2E50FBD76A6AE6835AAC76B7D36A5679C8EE358BDAC43A661789D5378EEC879A2EB09103A35A7733D615EBAD13CB6DE5FBCCDF68B02A168EF27718345F0478347ACD539D9E4F9FB321970AA8E2435ED44D0CF6B2E4D323DE157EFFFB9FE6455CF71A155472465EF337B8386A2B874E450E88DEB1108B14F3F289540975FA887D3D4EC4CD93EA9A987CA148F59A8D0A89CD74FF49ADA416631B33A7C2A2D724B5975A16EA445535968A178AAB1E67EB449C7A57F75365ABC9C65EAB48CECBB1D50B4FB2C1E2623AD9730DCF09E835F557921B6E3C5F6E4CE5D9E0EA3048CCB01B5BD9206F575C89BDA998E452B488408F74B2E5A6EB641DE4C566ABF6D6ED4CE5437ED3E3AA7E96E950AF99D566F90D8DCD8CD5B768A83A156A6024AFCD59D8EBCA5F288F05274971CB94584DB8582D67BAEAC88527B3791C874F9F6D995EF3542A7ECCF9AF5E1C974FDFC4EC5A6F2AAFBEAA6711F76B3EE29DE9B73F9B22CA75AF518393EA5EBC288E5D14D7D7CC8A2B5B42A3D7CC579B6C3F4F64EB910529DBE9835486C334552BCED7275F92CEF6F69AFAF19ADDC43E3D1E56262F0D1BCFF24FCBB059D8EB4AF45B930D4E64F1D2DA8245F19262E1D8DDC50143EF35E4C66EF8B9B1C96F84B287416979A18ADE99C4DE952F60F49A205AA79BD9441D255DE78B895459E67B5E9E0FFADADE55905436A0DDF19AC818DCACD4B28FF79A58E5DCB6D2DD8A176EF29810EF7A9AAFA67C26B0174E264F9D79985EF3646AE8643D60DDAAB06F7EADCB8BCB6FFA5479914837B5CBFF985FEB31EF2A7EFBEF437511C7BD4607D5D69AF1655DC696DE6917E5F366AF910F2C13195A2A41D49C33CBA205E99B1012F9555A3DC2521E7449E6A17D7DCDCE9C4E540DBD924AAFA99F1E37DF90194BFA85F2B0937E67537B0B66AA939907772607A6356E67B8BD86DC280C3D37F283A1956150541ED5D43BD3B47CDEE835EA24D3AC38AB2C7768B1CBCD8A7C107BDBA658DFA67A16F850AF4917B385FD4362B68A7CD959A5D7D47FAAF281D1AE32854D9136911EB2E9FBA9CA5B2B963A2ECA686A75B971137ACD93BDAA5CB2F760CF98B52F9FAED47413B7EACCB87EF9B74AD6311FFAE3DED5556F7570DC6B7450896BE8CABDD8983846EFB4D3F246A45AAFD99939A68EA2540E74047BCFE71CBA73407CDA8C3A63BD91738B1ED36B22BD1D9558D22F5C165996E4B1546EC1565F36507E17779F8535E05E436E6843CF8DC0E8FBC53028358E93E43BD3DAD84FABBD6667EEC6F901D8A9950FEBC9BEA9A90EF69A06626414C9B361AB502D3BA9F49ADACBF5C0A83A157A9136E550277FDFC61BD30B95D114D36B3AF7BE329BC47565E0D49C4FD7FA2557F6D357D545AFEB7770FACA9F7CAADEEAE0B8D74CCD79AB8AB33A41B947E7FBE5C63870D1D46BCA682B4F184DCBB1D0FECFCA3B7847A4BA7E303F2B7FDCF19A401F685ADAB164A46BBED17A5DC616E8AD2CBF8BBB1B3607DC6BC80D6DE0B9B136E7C92C460D6BFBB0AAD85F167634C8678DDFF0ABF269F5ECC23AFEB32BAF27AE6AD96B76E20A9E49A02F614E8E385E13E9D41075CD785AA7CDA6160EB1754571602E4CAFF1C1673572D2FF96E208B1F5CFDE984F77C5230FEA88B21EAA3D548E46AB49B8DE74FD268FE2553E59B73AB8ED355924C5CAC2DC8B8D1692EF97493DBBCC5E2332609148F985C6324F221D4EEAAEA365C3A984478AC33A941F5CB7DC365F5F538B0CFB0D05E537D42F14C7CCD586AEEBBD46871EBDA61572431B786E449359BE7785C6302836AE62C9F717F382DD865E230F94282A6AD6763EC89B311BE75868DB6B76DBB9F88CDCE962B33CF2FA9A6012E5EF716A9D84D62F947769AA6DCF2F39ACBC3173617A8D0F527540F9555A7C65054C633E7DBBBC78A17F1C3FDB47946FCCDB1CF261D9651FCE929F339F1EFEBEDBEFDD21EA5607B7BD46DF6D99CB0FFE26F55E131FEE3589B51A798047DD271DE62F5AAA7B1EEBB3391C5B1C26C7DD0F35B7DFD0CA7C7D92BFC890D8AB09E935A72037B461E7461AD87B57FE6F62D683B2D714BFCDF7F49A9278819D0FF9540CD3A4B609AD7B4D213F84F458AF59DB6FB1EC24FA85EBDAF3C61B5B969942AFF1C7B77C9AAC9BFB87FB9B571765F2280DF99485D8651942EA887231B47A75F1AA38E99EAA83D5B75DBFC5E39C299FFEFEFD97774FF1DB9FFF38ED35693938919F11959FE32E3F65D2EA35FA87614FAFC98FD764E4519AFCE376E5C7E9EED427EA4ECA091E0A4716876D7EA07A7278FE9A345BCA7C4365A418BD665A6C6892EEE8350E901BB961E7C66A32D53B973C60930F834EEB35E54E288FF56CD4104BCFF6B254F3D984D509C54FEF35A13A45143DD26BA24958BCC7C0381055BCA55579BC268FBACA09B66447AFF1CDEDE585E185316C4AEF6EAED5B0ECF2FDCDAD8A9DF4F6FA45F675FE65B684CAA78B3737F93D999FB341D9FB9B9B9BBBFCA5570FADB7A81B67C9A7BF7F7D523849BFFE5F97BD6665DE32144CF44D50E6C431F97EB99C1C3C5EB36DBC7E465EAB57F490AD9AA9ABB2CC91C54157AD47E61BAEBDA1ADB1B0DCFE792DCBE8354F476E28C3CE8DB9710DCCBA1C069DD66B6A6BCFF3A1F8604B5974AA9F1B7E7AAF99AA13678FCC379C9AF7AF5B57059AE7A1ECEF592D6C3B7A8D77D29B22A12EAD4924EECDE0CAEFCABCB7BEB496D0AB7B6FC65D1F66A050CE904FFFFEF6F470FAEF83DBF3506650C9BD38FFB2F5F535BB49F3EF7F31099EB15BC793DA6DD3471687457EBCA8F2F950D58B0B67D5376496A0446FC2DE2D08E835272237A441E7C6D6DADFCA51C3B27E7DCDFCF0F535AB3D7D6469E5C336AC0F834EEE359B7C14B4B64B58756E196B60B49E186FC3BC6ED81E4E557ACD7647AFF1507A7F77F3FECDCDEDBD7D2CF9E1C6746F3F765F5BA25CDDDDCD9BABCCF5E76F2D36A26BEEF3E9411F49FECF89E7C9F3E9B65CF61A6B7062EEC553EBA240B15F6E8DBDB9A9D7047B3E096F3DB1A6FDAD5FEA7B6471D07768D99FE75D9D057D6B7D332B96CC5E631FDCE67E2827C88DDDC0736369CDD5500E83CCD3D6E52D42E64D08C96EB7E73EEF8AB975BFF736A80D834EEE350B7D2828B03ECFBBFAEAD06A3A813D9A2BEEF3B623C178638B724E2C7A0DBCE33C9F1EF2703AFCE1747BC3E9F7620E5197BD66691783A0C8A7C5C4BC2850EE97B3FADC5B66AF892A77662EF51753D99D8C632C95796C0E15874D717ABDA84769594BC2FA51EAD85E7B601CD1D109B5AD1DDC2EB760A597A7D7E02483CE8D99759CC21E0655E6B632E7B36CE8356950F96DAF5FBE91EB8CF54BA3DA99E696BD262C5E5E9CC08ECCDDBD7A38C83E24A5A6BF29DF5931F1FAD4EAEEE51B4BF5F08B5E031F39CF277930F9B7EF8F2CB5279CCC8FB373D96B66F6EFEC45B1171BBFFC63E372B9F243DD6ABDA6325FCD2ECE5BCE56859F5EDBA2165465718883A0725438D18327316579FEC7B9DEB2A64C9BDA6B3763A9583AAC9E0BB33EC9A1F2390AF41AB431E4DCD8540E7496C3A0B81CD4E8FD25B43E4436C9972A7EC32F2AA30B236D62F1FFF90E3AADCD2F73A8D76C669359E5C474515CE2627B92E21A9E69FD18B37D484A7637639675B5F9220967E666956F6CA143905E031FB9CE2779A4F88F7F1F5BAC9E4DD6DC5A82C35EB3AD04D5A6BC7753CEB59965C4766D4E1F3E598ACFAE141FBD5BEB35EA93DED407DD89BB8C629574E263C1D56D4C32B892A07A12A82C0EA24B55AE9749F2CF66D8180342517144EA250D33015793D78CA52201E52DE90BF96775E396DE826D391D3CBD062719726E2C2A875A8D5183385ABBCEF6FA64A9B341ECA6B324FB6F1237F51AB9B347E225EAA312743EA80F868AF391C7A25E3C0EF59AA8762876A78751E6E1E448DDA3992E2AF544A80C8C76536B3417960FCEF3A8B3DE5871BC975E032F39CE277934F93F8F2F57BBDEAF7EF8D955AF49D7E2F683459CE807127963F4248CD7628F9513E905EA7FD3A56C0B91F150B84AD3447ECE5C92C7859E726236D11FEF1D44F24E49F911D9A2F4C4F1BCE10687039FE72D1F9AC5D16C625EDFB7915B14D65695BFA1A55E456ABCA18D4CD7682D9F5BA9FBCF437D2C5C64501CAFC5C2AA46C9CFFA8E12DDE1AA9F5A75227ACD080C3637B6AB453099C62B5D0EB6EB584E5015A900917BDA349FD245168174663C14256A84345D25F9C023513BE16C5A4C4B355BC8FD35BF6769328F45470AAAFB5E911169B28AE52664B9B296F335C84F4E99D7160FA285DCD5EDDB9CA268523D9DB4DB2CA322FFD4D7F24EEFE962B9C9BEDB546EBE6C626A6AAED92C1FD7895BACE278296F4D5FAABF1CB1F05A8C0B13F9AE9F32F912BD06CE38CE277134F9977F1E5FAE7A13430357BDA698494F3F50CE35257B86BA477BBE96CBA981DA6226636213AB231ED515E4F3D5A8794293507D15C4E54B27E5347DA5F280C8B4761DF0265F6330378FE36C22999661E58456757B8CA902CB69C0E4B7DFE473F3E5F39B1633F5CD54FEE81786C5DF89934FBEA4D78CC06073232E770AEB6BBDBFA96C586CA3627F49E753B58FC9BD751B565690E6336806F17657CD87649EEFF88B5A21B00FBBDAFBF5AABEAB4E8B5DDB783055956CB6A89CB4D29B1857BE166567626E7EBAC8B74FCDA75E3C99BD7FEB85C59F9E72C4865E0367DCE6D3FF44DEFC79C482D59B181A38FE7CA843B6497556ACDD263934F4489365B23196CD27BECB9FD313F6D98C133DABFAB8669BACB297D5B76C597FAC95CD7A556C5AB605EB6419279B27ADF151F49A1118736E6C92DA4387F7A9ED7A59264C251FB6C5847DB6C9A10B853771FDFB254B33858AEFB65E3F6D026B33EAC4A9A6CD3A5E254F59E15EF41A38E3369FFE38EE68B2CEA7DFFF3C30447BC65EF32CDC5DC0F2842D489EE1DBD06B4680DC38B3C9F3ECACAD3CF9129A83E83570C66D3E89F942FF77CC82D59B181A0C249F0A6139F745775B903CC3B7A1D78C00B9715EE964E2EE57B32BF41AF484D37CFA470CA61EBDA741F8E3F1141B463E49F23073F703307A0D5C2137CE47C44542AF79127ACDB839CDA7EFC71E4E3E46FFF3A910C6E66C12DD6D46FD63A6CE815E3302E4C6F90489BCF3FB8C15E244F41AF404F9F40CC2599A3E53A938B819CF73850FBD6604C88DF399446222AB60FBF4353946AF414F904FCF2094F35BCC9FBEA2A748C4AC37619C9C3D2EE93523406E9CCF641204DD8F826A3662468C69BC3ED7ED94F41A38433E3D83380CD564375D9A5426AD381B7ACD08901BE7330F6741E4DFD19AEAC43CAED16BE00CF904C7E83523406EC0317A0D9C219FE018BD6604C80D3846AF8133E4131C1341F0A3DDE25D6F32DA2237E058CBDC388C5E336EFEE6D33ADBB2EB6EFE52F0142D8380DCE82372038E390D027ACDB8F99B4F8E3F590FCF44FCBB452D962737FA88DC805B6D73E3307ACDB8F99B4FDFF981EAA54F2D7FA2F867EE2372036EB5CD8DC3E835E3E66F3EED5E679BF657277F29788228FB67BB6BB13CB9D147E406DC6A9B1B87D16BC6CDE37CFA986DDADB4EFE52703A71D9E6CB9F2D5E406EF411B901A75AE7C661F49A71F3389FEEC44F54C71F818D96E4598056976D921B7D446EC0A5F6B97118BD66DC3CCE2739A1C16B6777FEE119FC7CDBFADF8CDCE82372030E9D901B87D16BC6CDE77CFAE1B8C3E3DC643CB59C3D84DCE8237203EE9C921B87D16BC6CDE77C52E75CDF32F2EA8BAFAF5FB6BFB681DCE8237203CE9C941B87D16BC6CDEB7CFA29AE917FF99A9B1B7AE187B860338BA79617FF911B7D446EC0911373E3307ACDB8799D4F79917F794D42F9EEE79D4AA7F6F1446EF411B901174ECF8DC3DCF61AF491BFF9B4FBF136DFC6D71FE0B1E267E963EB78EAFAA71FA72237F044C5CF52FBDC388C5E038FF3494D43899E787DC2C45A5D6F334E456EC08D5372E3307A0DBCCE277D4C19DE7BFDE5944157D75B8D53911B70E1B4DC388C5E03BFF369B7FBEB2311E5BDE8E389173374BDE13815B981273B39370EE3BAE171F3FBFA3F63D55FE1B127DC534B6EF411B90107CE762F3EBD66DCFA924F182A72A38FC80DF88C5E336EE413BA456EF411B9019FD16BC68D7C42B7C88D3E2237E0337ACDB8914FE816B9D147E4067C46AF1937F209DD2237FA88DC80CFE835E3463EA15BE4461F911BF019BD66DCC827748BDCE82372033EA3D78C1BF9846E911B7D446EC067F49A71239FD02D72A38FC80DF88C5E336EE413BA456EF411B9019FF5AAD76C63C97C28918FACCEFC8DCF4FBDB3ED710BAFDA2C7C18F9846E911B4F416E00753EF69A2449368D4F6CE7E124632D1BCEB24742777F2149FAE822697599749DD43675BD39BC8A24B1F2250A83EC7D24BBA32CDB2C7C18F9846E911BD6A6921BC09379D86B362283F60D2A924A3E656287F9944E2741F2C832ABA9150DE94224E4243486834934CD1E09E6FB8783CBECF959FD9D3DF6AD0FFD359C867C42B7C88D7223C90DC0050F7BCD42ECEECB3D4F9E399F56D9EAE7079748423B47D22C9D82C53C7B30D20F6DB251D12C16A9B537A0A6F50C269F3046E4867E88DC00DCF0B0D7C87D77BAE7C933E79318F3C5079EDF8A20327344C493C8D26D580454164F72EC964CF706941C5A4E16B57796EC8E443E6120C80D7283DC805BFEF59A643215439BCDBE67CF9A4FBB781A1D38519E7DABE9C2CA91487FF36D31CC9AEA885BED3D2EBE98CC6B193C807CFA33CBA7DF5DAD0CE3406E901BE406DCF2AFD74493C5AA3628299C3B9F0E0BA224FB2B33732428BE58E447A2B331559047DC6CDF71F160B21101B5AEBEB36477243FF3E92ECBA73B572BC338901BE406B901B7FCEB35D9BE9B8AABE79A9FED369F24334736E5657C7ACBE2325BF76DD93A1B72ADCC33EBFAF5C9EE487EE6D37FC927B4456E901BE406DCF2AED7ACC40E5F1B9408E21EC7CA8EB9157776D653401FC44DAB07A5D3835F1EFB5766E4C8C2F8DEF936CFCA33ED62639BBE4724122CA83C59CDA7A4F632E336513FF3E9B72C9FFE76B5328C03B9416E901B70CBBB5E33178760D7F5DB0B9248ECD093C0D83157EA62BC4066C43614B2FF2E43950FEB505C48382B4E7BC7F2BAC259A8C26B3B0FAA775966A328B98EFC9ABDF5D41E17957F65468E84C681EFFCFCB811AD9BE6A1541A88D3E751E5BE07339F3673B9ED73B9AD73B1515BB9F9B3455A2EBCDB46E16C12C4A7A56CCE653EFD93C5D3BB7F1CAD0C23416E901BE406DCF2ADD7A4EA92B9EAA064ABF6D7302CF3692DFE28F6DD7C7EAD85BC6A309EE47726C83FC84492EB49A693402D9BECD4B3D3504CCD658DD8B6B148AD3CB2A6FBEEB7344327306E830865A65A99D47CE3A91C5ACA8831BFBB914FAB20DFF6400C1CD7E1A4146C8A8523FD50B23B9DCB7C12A7C97F75B42E8C05B9416E901B70CBB75EB354E3ADA8B2676749A20650C581D46DA097288E27CB315810CAC888D5F067A5E7B19AAB20D9043203B6D9925BF96DAAE7B1431D38A90EBAFA5F991D40663E8595C3C2CDAB98AB0D9FDAB73D942F5CABCB1FC57416EA4A4211C4CB2495E34CB9DD2ADCE27522B36BDFBDADC770984F0F62D8F55F37EBC268901BE406B901B77CEB353335D6D94CAC79358BBB228B7C4ACBD3D1663E45D9B024096271C856059D18C26C64DA4CE5AEBE91A394A57E71BC379FE4B9FAC6BB2D9F9A4FDB7C48B9B09F2D5F38CB377633CD23B87826D6377C24D6434FF8C41787F9F49F2C9E7EF9D7CDBA301AE406B9416EC02DCF7A8DDE77ED414952CE4B61DC3DA0EF7C30F32911FFDDACE4D3EAE56ADEAB551177A978B8BC91B27A8560994FE96AD13C17861140DB4A3E4DD5482F3116ADDF779A0F2D65061B43A62272ACEC99D9DF31CC8762E5327BCEC51FCB5D3EFD2D865D7F3A59154684DC2037C80DB8E559AF59E86BEE16E6AE1D9561A4F3695A5E2058CBA79D3E679DBF365487688D31CEBC88AFAAF0F0BCA1956F9354F269A2C64189B168FD86CD993EFD3EB3A2A5889CB8C8D265FE66CBE5B6F91F8DD19D27F924E6D67AF79B8B356154C80D7283DC805B9EF59AA9BE27606B0E4AA6E56E9EE79339E069CAA7C03CDA3C53CF1957F3C98F8F6B0CA876F974CAF1E44D31FD96D88AF2D689E28561EDE0B9B1CA7C8DBEE5D3BFE260F2BB770F4F5F134686DC2037C80DB8E557AFD964BB666E62DCF7688CC1F25D36319E6DCA2779799CA44643F2ACF764AAEF6DDCAA9B35D7F52D387F3E2DE40D1682187795D38899F93455DB1EE5C7D1ED37B6D8F9964FFFFEFDCB3B2EFEC349C80D72E3A92B026C7EF51A7D0B624E0F4A26F694553B3B05F6E493413CB250F736E609B599C92F6749750BCE9F4F537BDB8AC160F1427B81C4FE8EF910D4693EBDFBFC14B7BFFF3FEF144E92A33D7283DC00DCF2ABD7049365A2899D331F269D944FD560D8A8F0CB277248572AA12AB378B5CDA7596D1E8AB4924FD57928924950BCC5D8DC80E22DCD6A27D7ED03E5AEF3E99D1BBF713019272037C80DC02DAF7ACDDAFC749779392839299FEA3714A4CBA979665A0556E5DE8596F9141A013329E60DD563A9A68F6E898C53E372AE8B6D75E1F0503E4D7CCDA7FFCB9D9A3805B9416E006E79D56BE6E60CE4AB49B19F1A373118D7FFE9114D533ECD9A6E28D8A91B1ACAF948C5E9F24A8CB5CCA765F97DD23CECE6E51AD60D1FC317981F603337DE461139D1A4FA192EE73D4FEE68DCF52BE32E9C80DC203700B77CEA35A9350A320625F3F21E077DA97F500EA0F6DCAF39B356ADFF1BC851911EEB2C6B01D2329FB6E50A7418ADCA2D5BD48F57AFAC6F2832D87C6749FE7E2A9F7A577E4791CBEB9D57E7C9FFCFFFC903EA173EBA0EED911BE406E0964FBD6665CFEC3D2F0E23AF27B5F9B51607E6D7DAA91DDF3C431DAFCA9566FB777EB25CECEE95C9C48D7CDA26BB465620CC8AA3C7619E4B6911AB79185AACA1A5CA60E39DC9F56ECC83DE95EF18D5E6D7F2E0BE867FFFF7874A28020AAD911BE4C613570454F8D46B66F6C15D635032D31F4357E4D3B61C7835E593FC003C231BE2FC8B3C90F4558071EDFABC329F16FBE6E0B20261A5B7B1BC8334D25B165B07AFA5B472627E5E9ED02F2327AC9EE52F9E69985BD4837CCAFCF3BB1C79F1A1BC688BDC2037C80DB8E551AFD956F6DD7452EC7AE2535D66CBCD66B598E993C8E2D3DDE6AB6DB28CA64DF9240ECA06F3E56697ACE3ADFC5204D426547B7E7E7BC332A87D464AF9F975C1A4F14375AB8190A5D17CB34B57D3220FE547D06C77DBB8B889A2B4AC8CF3C488321F3F26560A4DC278B3DB2471627E47F14DE2CAC27EE493FA50DE77FF71B1268C0AB9416E901B70CB9B5E138759204CC358E7453C5737548651B253FBBC9A3962A2E7C5DA04EA91602A926893C6620C338BF5145AABA098CA6193C7959CB42B14DF40AE49CC6F155827C59338121B11C522569AF2295E8461A05E1CE92D95DF36306F104DC5ED13E1A4161CDB857870368FCBAFE59C1341B8D82EE399DCFCA53C5A5C6EBBFEFCBA591846C55D19A99C354C24582AE7E09A35E6E851DC7DCECB7F4540FDCFC9AA3022E4865E8ADC00DCF0A6D7E8F9423795AFC3500E67529157D3789B8A47F2CF7F8BB3DD7BB64A13F150BCA9AE6013856AFC22F6F8ED72AEA60A4DE4736B9914D9DE6E1FEE5D98DF72A93FCAB76123CD6F94AEE5C84F8D9094ED2AFB6E72D4672936B1FA75B62E7BADE942C6E02C5219280EAC8BCD9DE699B8293653FF29D99DC85D3EFDFBEB3B3E9717AD911B05720370C29B5E73169BF4092F4E37472FBA3DEAA176B6E5B6CB11DC2671F937A3B9CBA7DD7731F0624A74B4436E3CF6503BE40630EC5E33104F3B157E90C37C9247947F7DA6BF120C05B97136E406468A5ED3033DC9A77FC4C08B5B1BD00AB97136E406468A5ED3033DC9A7DD6FCC4581B6C88DB321373052F49A1EE84B3E897B36EF9EE7AF0443416E9C0DB98191A2D7F400F984C12237CE86DCC048D16B7CB78DF3D92B9E7CA74413A7F9F467964FBF3FDFDF0C8680DC380F7203E345AFF15D6D820DA79CE6D377A60E455BE4C679901B182F7ACDB8914FE816B9D147E4067C46AF1937F209DD2237FA88DC80CFE835E3463EA15BE4461F911BF099BB5E13653FE95FBB7E3B68E94BF6AFF6D1D5CAC827B4466EF411B9019FB9EB351FB29FF4BFBA7E3B68E953F6AFF6C5D5CAC827B4466EF411B9019FB9EB351FB39FF44F5DBF1DB4F436FB5773367504F984D6C88D3E2237E03377BDE62EFB498FBA7E3B68E787B8BAE187ABB5914F688DDCE82172035E73D76B7EBE74796812CF429C0478EB6C6DE4135A23377A88DC80D7DCF51AF9B3FEDA5987C733F8CBEDEF14F209ED911BBD436EC06F0E7BCD8FD72EEFFDC3F9FD7CED74D8453EE104E446DF901BF09CC35E23EFFD7BB9EEFA1DE1583FC5259B2EEFB1259F700272A35FC80DF8CE65AF915351BCBCFED9F57BC251BE8B7B1ADC4D42B1239F701A72A34FC80D78CF69AF119350BE7C1931CB561FACC5C1E497AF5DFE36219F700A72A347C80DF8CF69AFD9AD6540BDBCBEFBCAE0CB673FBEAEE5A0EBE56BA7BF4BC8279C84DCE8077203FDE0B6D7ECBE472FD11F1FDCFE1A39533EFDBCBBFEF0BAEBBF2A1C127DF8F8A43983C98D5E2137E0C45373632FC7BD66F7F3BAEBBF2A1CCDF5AC2167C9277EA27AE2F553660DE65FB947C80DB8F3A4DCD8C775AFD9EDEE187AF5C3DBEFAEFFE9CF914F7F31E2EA8D27FD44911B3D416EC02DF73F5167E835D98FE9A70F6FBBFEABC2411F3EACCF3013DA19F2E953D77F5368E1F5933E3288DCF01EB98133785A6E343947AFC14839CFA71FEAF75CF4E9ABFB460F87BEFEF5518D8FAFBBDE12F40FB9315667CB0D7A0D9C719E4F1FE4CFFC276E92E9811FEA1F8B4F7A425BE4C6889D2737E83570C6753EDDC96394E7B9601ECEC97983DD7DCA33C682DC18B573E406BD06CE38CE27F53134FC9EEC8DAF7CD2134E406E8CDB1972835E03671CE793BCF68F49687B448EBC1827A31D7263E4DCE706BD06CEB8CD2739BBFE39E636C0D988EB359D4EB18F112037C6CE796ED06BE08CDB7CFAC4EFC8DEF9CA011BB4466E8C9DF3DCA0D7C019B7F924E669733EAF01CEEBE34BB71FF58C11203746CF756ED06BE08CD37CFA212A3CC3AE9EF94B4C1BD2F546A05FC88DD1739D1BF41A38E3349FC4A1C9B75DBF23B4F453FC56E97A23D02FE4C6E8B9CE0D7A0D9C719A4F77DC33DC474C6183B6C80D38CE0D7A0D9C719A4F5F98BCB68F3E708F2D5A2237E03837E83570867C02BD066D911BA0D7C057E413E835688BDC00BD06BE229F40AF415BE406E835F015F9047A0DDA223740AF81AFC827D06BD016B9017A0D7C453E815E83B6C80DD06BE0AB71E6D3ED55E9D67A60777DD5ECDBCEFEAA5CB05CEDC36DF6E08B8BABAB3737F75DBFC516E835688BDCB8B51E20379E8C5E0367C6994F3717A51BEB81DDD545B3FB9DFD55B9A05E697A73692C71D59F84A2D7A02D7283DCA0D7C057E3CCA75D7AFF4285D37DF1C075F6D537113B2FC460EAFA462DF0FEE6E626FB5226D2B75B1540EFEFF397645F7EFEA65779275FF0EAFAEEFEF31BB9DCFBB4EB7779247A0DDA2237F403E48623F41A3833D27CD2C3A6CFE503373283B2C76FCC05F2FCCAFFF0593E769907CFFB0BBD6CE6DA5C5FFA4A2EF7D0F59B3C0EBD066D911B1AB9E108BD06CE8C3C9FCA7C29F3E9B3B9809D4F3B993B176FE49F6FF51F846F6A44567C79592EE73D7A0DDA22373472C3117A0D9C219FB4229FEECD05F22F5EE47F50317471A7FEF8AA3C622C83EB45B9B6BB6239FFD16BD016B9A1911B8ED06BE00CF9A41DCCA7E2D11B7D44F9E1F2E2B238479E1F68BE2ED796CA075EF4E25439BD066D911B1AB9E108BD06CE8C3C9F8C81519E4FB7370FE602792C158FEED46581D7E24CB8F1E217B561967AF96DD76FF318F41AB4456E68E48623F41A3833F27C326EAAFC6C7DD5B080729FDF8E698DB21EEC3B37851BFBC4B9CFE835688BDCD0C80D47E83570867CD2EE8FCBA7FC06862CA18CC7EEEAF9747B513973EE2F7A0DDA22373472C3117A0D9C219FB463F3297D513F05AE0659AFCCC5EEEB91E52B7A0DDA22373472C3117A0D9C219FB463F349278FF9CC4D6D2436E27CC208901B1AB9E108BD06CE904FDAD1F9B47B531B78914F1817724323371CA1D7C019F2493B3E9FF233E5F6BD9EF6ED9A63CE278C00B9A1911B8ED06BE00CF9A41D9D4FB7F9058017E5341437F59B33C79B4F1801724323371CA1D7C019F2493B369FBE5D5E5C5E55AEF7BBADE4D56ECCF9841120373472C3117A0D9C196D3EBDA90E958E9C87424CAC759F5EDA4794E534E997D6720DA7CE7D45AF415BE486466E3842AF8133A3CDA79B8673DDD6027BF2E98DFCF0DD7CE289E28377455ED99F56F7BEBA7E7FD16BD016B9613C602D406E9C885E0367469B4FF7D571D1556532ACE67CFA9CCF057A65BF5CA4D1676BC117F543CCBEA2D7A02D724323371CA1D7C099D1E6535A19393D540FFE36E6D3BDFE30DE077544596792F8D2CA2235437A2FA643A7D7A0357223476EB842AF8133A3CDA77C60541C047E531D3835E5537A79719927DA67F9B4FE4A1C8DB6F2491E4EBEECC5C7F2D26BD01AB99123375CA1D7C099F1E6D3B70B7368F4BE32C379733EBD321EA81C517E654D87FEB97E03A7BFE835688BDC505F911BCED06BE0CC78F329CF908B17EF3F7F7EFFAA7EE8B8219FDE9B63B3FC88F25DFEE5B717176FF4C2DF1AE6DBF218BD066D911BE406BD06BE1A713EED6E2E2F4A2FEE8C676EDF5CE9E7AEAEF27B136EE5432FF22F6FDFBCCA1778A56349ACEEEAEAEAFD1BF5D2AB5E5CFB27D06BD016B9416ED06BE0AB31E7D32E2D12EAF2C63A987C7561AA3C565B42DF94F9F0BE0CBC57B75DBFB9E3D16BD016B9416ED06BE0AB51E793F0EDFEE6EEBEFEA0A9F2586D8907E385773799CFF7FDB8F02F47AF415BE406B941AF81AF469F4FA0D7A0357203F41AF88A7C02BD066D911BA0D7C057E413E835688BDC00BD06BE229F40AF415BE406E835F015F9047A0DDA223740AF81AFC827D06BD016B9017A0D7C453E815E83B6C80DD06BE02BF209F41AB4456E805E035F914FA0D7A02D7203F41AF88A7C02BD066D911BA0D7C057E413E835688BDC00BD06BE229F40AF415BE406E835F015F9047A0DDA223740AF81AFC827D06BD016B9017A0D7C453E815E83B6C80DD06BE02BF209F41AB4456E805E035F914FA0D7A02D7203F41AF88A7C02BD066D911BA0D7C057E413E835688BDC00BD06BE229F40AF415BE406E835F015F9047A0DDA223740AF81AFC827D06BD016B9017A0D7C453E815E83B6C80DD06BE02BF209F41AB4456E805E035F914FA0D7A02D7203F41AF88A7C02BD066D911BA0D7C057E413E835688BDC00BD06BE729E4FE8257A0DDA203720D06BE023F20902BD066D901B10E835F011F904815E8336C80D08F41AF8887C8240AF411BE406047A0D7CC4F57FE0BA61B4456E80EB86E12BF209F41AB4456E805E035F914FA0D7A02D7203F41AF88A7C02BD066D911BA0D7C057E413E835688BDC00BD06BE229F40AF415BE406E835F015F9047A0DDA223740AF81AFC827D06BD016B9017A0D7C453E815E83B6C80DD06BE02BF209F41AB4456E805E035F914FA0D7A02D7203F41AF8AABFF9B40A8585F9D0423EB47AAE2D70436E73B869F3A68F5CF858F41AB4D5BBDC68C886567B9EBF1A8270BF4D9B851F41AF81AF7CCFA7348EE3E6A2B25DC6D3C924341FDAC48B6032899D7DF3247E3CF492786B6FD62A8A93366F681D4793C9E4D04BCCB5B759F858F41AB4E5696E24D9DEB5D9F34C54CD86553C77BA331951B0111BB23EAA32A5D5B848E2C53A3DF08255B66AF3F9AD4CBD7077947429169E3B79BFF41AF8CAD37C2AACB2E499ECDBCBE3FAEE1C3AEC35E27B6F0F2FB29DDBC1B89A4EA4F9DE605A66CF0695675BA52BBD06DDF33437669303BFB41BB2C1E5CE24E24235993C042693E9E3591407D646A573F5CAD9DECD4AC5D395A15E7874AFD9398C487A0D7CE5693E1542B1172FF73C79E65E230E8D1C5C591A4FEC605C675F4649165593D9BE62336B88257A0D7AC6CFDCD84E0E0D83CEDC6BE6C58E2DCAD53A914783A2C3AF91E32063A3D22C1E66AB55B6A5C1BE833D6260548D3D7A0D60F2339F0A2AA8667B9E7D86E335870E252F8389DD6B36417E2866BE37D0B693A01E4BF41AF48C9FB9217FE7EF1D063DC3F11A7578571F905D3E526C12396A33364AD41AB9F5EBFDC5460E8C2AC791E93580C9CF7C2A2C27F3D9FEB34167EE35BB55B4DEFFE4763A09A2D80AC699FEE6A28E35BF743189A6B53744AF41CFF8991BD3C9F2C030E8CCBD66B75AE4EB2A4E852DB2F5EFBF46370B8FF96A666E54B6F5D3625B9BCFA76503A3B8761C995E0398FCCCA7C274B25EEECF8673F79A8336A2F4246630666D669A1F035FEC1BA8E56FC8DE467A0D7AC6CBDCD84C82DD8161D0B97B4DB956FD6DD6075A561612CB6D65A3C2E214F566DFF9B46C6024464DD3EA3BA3D70085872C9F7E396AC9BFFF7D7411E7BD4604555ADB8B0B9DF61AC9EA35CB7273B2C783E6E5A7BB7A2CD16BD0335EE646F63B7F776018F46CBD26291A89386574785973A35263E960CF11DF6C60242F3A4C2A2BA1D700A55FB280FA7ECC82D9F8ECCF7F0E2FE2BCD788A092D7E3D576F1751C2F9385B93BA7AB385E25D59D365DE783B7CD6A99188F6F936455C6CF2E4992C377656EF6DC3D6A268C714879DF89A84864EEAC7ADD8E15536912AFED01679A2C8D1B3FF385D3C4D9C41BF41AB4E6636E04D96EB56D1A06A5CB5A366CE58DD8D582B0D557F467BB9CB97FD9F990665F258FDC29A994BD264D9A2F6736376A65F49AB0F988AF18E9C9E5A2CA4A8C5E93AC56956C4856CB8DB9B0FC8E9BE4D0DDE447A0D7C05BBF67F9F4C7310BBE137EFBF3E1C022CE7B4D2052A7B617EF368B40DF49A977E775A41F113BED66A20245DC5890AD61972EF2A5F33D39BF604F1F5389F3D55967B463F3A2E0F99EE3C956AF31CF2FEDB9954A246FFD0D192B49D43DA2C12AFFAED96AD4B64E57C6C26BF95898EC9CA0D7A0350F73632D0B4D7D18B49E9BD920A4AB59F150A26E7CCC9EDA2EA6AA576CF21BB5F5719FA5950F5BBD3AAB3C58715128126A1D4C82EA9392D96BCCE3CF8BE643307260944E2A87838D5E9386C64C1372968CB98AB7609196DF712BDF72103FA9D9D06BE0AD3F45EC3C1CB1E0BBDCAFFFDDBBB4EB5EA3822A0D2AE79AC5DE3ACB865BC6BC7C91DC7FE3625EBE959CBE6E9647CD26FB43108A1D5EDD6410ABD7072AC5D26C35512CEECAB482649B9417056F6A3196ABF69AE2CFB3C65EB3526FA81A4BE50BC5B79C85D33C53D35805ECD4BCCD43BCB812D34F44AF416B1EE646A476FD868319C17C191B73768A449946D943F92497A9183BE4BFFEC51AC43C0DE1AC588FCA8728CF07D150B2F098558FF4ACE37AAFD914EB08F74DAC63F61AF3B04BDC7C064B0E8C64DCADEC95E42FDC88B726A34ECE34B1CA0745F2ADE5734F843A5026E5F58027A1D7C05BFFFE72E41580EF4ABFFEF1BFC6455CF79A488D982A7BB1D87513F9A7627CB32AE6BAD33191C8BD566455A2922D7B3A09F2A32EF90AB26159FE62F9E8B236406AD76B5233D7C2C6B3FC73554EE695582A5EB8525D252DC69CE268F446CCAD3C3527C788926D36E4ACDF5775227A0D5AF32F3752B53B548741B1F90B3DD67FC89B8FDEF3E4D196D9622EBAC4362F23513E9658E727B6562A1FE6EAD174D67470A6F2503953C4DC4DAF51233D793DF2DC5E897AA16C6C3BA3DC65AB998AF34DF29855A8179E8A936AF2A0F5BE7BE28F41AF81BFE4C0EBCFC7977B67F9E58FFFD5AF0774DC6BB29D54FEDE5E5B33BE88C32BF9DEA87BCDA66C1D66AF110F6DA689FCF3CA586EAD632D957DA6983278B5B7D71C751E2AA9F49AFA61E43C796BB154BC30D4D706E809708AD4DB147F07C5C2C9C4D1458FF41AB4E75D6EACF25DD41E06899960F2F6AF77A645B9331BBD66B695EB90AF5783A47CB9A8C807B1CFA67A174DA3A4B201F5FDB12C50EB7D3B6BBB5E930F8CC4C8CC1CD384C6004F7D9B755EEECA535BC58D62E577993EED1315E835F0D87F44DC3C7E09E0BB9ADFABB73A38EE353AA876D69189B81C8EE99D362C83CAEC35F28174BB9B9BFBF6428D61D41AE4FF97E773AA473F8C2CDA24BB26ED7ACD4A3F568925FDC2C43A7093EECCD45BEAE7CAEFE2EAB3B0E83538816FB911E6BFF3ED61D0B43C2B95EF4C5BA3F718BD26BF0E463EAD56948F8DCADD2CDD593DA97A0EA7565DB6C66E9EAE1FBF6E38A8F49ADA11623D302A8E25952B092BEF367F9365AFD906E558A93C7B7FFC6D5475F41A78EC4186CDDD638BBD6B62DFEAE0B8D7E8C1899CDEAAD8F967E5CE98EFB4A9F174ADD7ECCCE2A276E9957D2BE86CB26F5AE1C70F88B4EB35339DA79558328F86DBEB32524FBF8BF2BBB8BA61935E831378961BDB62B8638E1A364689C9F797A5F174ADD7A85D4F3D9D9F589E5BF9B09DEC2D03D5B848678766E5B3374A6FF8E15E538CF436F65D5F3A6D8C53E153B55EE38DE9C3546534C5F41A0CD77FD52D0B8FDC8CF96E0FE35607B7BD665BC48FB5171B2526DF2FCD4271B8D7A8018AFCE4B8D83A00346BFCCC70C7BDA64C5EB1A8715ECB48D769F98E939D957A7AB845AF811FFCCA8DA535CB6F5C3C5ACB86B91D0DF2D9D81A2C4DCA67576A15D3321FC4C1E379E338A81A17D1818F892BB43A0F550C8CE45658B76ECB1726B570687863F41A8CC2BF7FE8E3C3DF0F1C567EB79FBED5C16DAF594E2C897A745BEF35ABC3BD6623EF3192F21BA8D43DE173BDC6E9BE7B1EDBF59AEA75C3B5E92762FB0D6D6ADF2794B76D49F55EA3E3885E033FF8951B336BE7D2C320B31EE4FB8BD91EF6F49A72278C6BF920EF9D9E840D03A14A5C2C8EA935AD7ACDD60E90C5AEFAC2A48CBAFCD84FE58D6D77F41A8CC6DFBFBC7B2279AB83DB5E630795AE09C545C0BB62BFD43BACD0D06B8C9D3D23C360A5EE940EF3E3CD6A428A7AB369D76B1EBDCF7BBA2F961A7A4D66B3A3D7C06B1EE5C6C6DEB9CC8913F422AD7B4D46444D251F923C3C92EA26D871B13AAAD6B4EA3595915EB0ABBE70598B3AE38DE94B97E935188B7F7E7B6A40895B1DFE5F97BD66635C5A2B062AF98DDC8971698AD16BF4C18F3DBDA6FAFB3F5D4ECD63269B4866D5FEFBA1F669332FDFC6B8FD746BC592D96BECD7D06BE0337F726361DCDA637C8EF669BDA6BAF2ADCA077DEA389F15A67AC8C68A8B55390BE84107E6E5AB4D9B3C35BEA518F5AD8D9554CF43D55719D36B303A77BF3E359F7EFFFBFF73D96BCCA0927BB1DAA7CD8B84F3FDD2BC87F2F0F535A624328F99344E07D3B2D73CF2390A51F50D150BE8952C6A916AA4DE8C5E03FFF8921BE6EF7C63D4705AAFA94F0BA5F2A138752C8B4E75E607330B96FB3EF8B6CADC8997F6C656EFC136074672D9B9B170D16BECD8A1D760E41EEE7EFFCFA921F5CB1FE2DE4DA7E7A1CCA032F762A38D18D70DEBBD794FAF69BC2D616E1D1E11F74156166BD96BECCFBDAC7D1C6FB0E70D35DD0FA5D9F74371DD30FCE3456EACF5F15CA91C06358C79169383D70DEF9B162A0DACAAB23C380C8AEA4773F63077E2ADB165D3FA1AAC919EBCD6262D5752DC0F654702D70D03871C0AA77C1A5197BD26B18A81DC8B558CCCAD8B02E57E19D4E6A8B07ACDAC32B4D2A3AE54CD3BACBF5CD68EFCB6EC359BFA9619D6D639262B96F44A56B5E156997AC5AC1BF41AF4C9F3E446641D1E29470DE56C34C5FEB2320EBC34F49ACDA4320BAF5E762D8741496AAFCD50EE99D12468FC30EE06D66A66C5FEBF6D386A640D8C647733DE59982F52394C64BC31BD10BD0628EC0927F3635F5CF69AC83E0C5BCEF96DDCFDA4F7CB6286D0E65E5399AF6617EB5D3F90D522D8148B550E1D97DF295D2E1B3FB2C01EDC15632CD198AA3394CFEDB597434AE3FB04136BD869A6DE5C4F2648AF419F3C4B6E643B9C5924EC615075CE4EE3C06C43AF9157B999F771EB2FD6B22BC5FA62E0796DD0A35796CEED15A857C7CD4DC7DA89CB23BE51FD34977D484A5D235CAE24D42FB30FF3946FAC38AA4DAF010A4DE1F4DB9DF559762E7B8D1D54B29BE407436645EEE8FD529C42AA7C068CD96BE427C6187B7B9C370C15543BBDB6B076494C59216A852367F79A95DEC6B87E2F445A59BB194BC54AE4543AE60B8BD44B8A4126BD067DF22CB9B1AA5C705F1ECCD8948730F4FEB22AE3A0A9D788A7037336F0A0F888A7B55852EDA0DBFA75BD7A6533F9399905B9AAE564CF6731593B71AA3FFA6E3BA99F86B20F4999DDADAC2ADB49E51873F9C6A6BACDD16B80423D9CFEACCEC8E5B0D7C495EB53E46D9CAA1888693CC507F446B3E216A64DFE01BDF3E9A4A1D7A82927A6D16A1D47E2EEE96CDDD17697C679764CE441E34DFD6624FBA3981A4F4955E22A96337825D5115FD31B325759FC2995F7B68771B28CD50DE97AEAF728303FCF3B7F19BD06FE7B8EDC48C3CA2F68710DCD54FDD217D9305BAC6231A34BBEBFACE44EB65A8493A65E238F0D672F59AFE2B9D809453EA4BB6D9E0F62C8B2513345542FDAD32B6BBAE3BCCC2ADB7626C348CB3636586CB7E2A3C7ABB5665B2D46F203C78BD15C58BEF12CEAD622EACC37262E7B9EED2A0BD36B307A7638D53EE34570D56B36F9D435E6A16145CE0B9CE64FCFC44E1CC89D7DA3E69498CCC55413D36413AAFBB6F5A9AC7CCA89899AB246CD8F270EC1E80B56F2E7AC2EA282703213AF30C746C54686E5043B53FDD248ADB85A6BF2371414E7F08D3734577F96DF679746C5E414CBF28D8B574F65246FF337967D213B9CFAB4BE27A2D7E07CCE9F1B2B3567C354F78C55B163AA4FC5CD77FE685A949D55BE8F2DD442F14CEDC4C67D96F902E291321F929D191E7BA7BB6AEA35D6CD97B94591025932E43526D18F54165E0465FE195F8BF7B00EA76AF36562AC8AA89B976F25100FAAFAA4DEEB4C9C5193DF7E7AE4F5CD0DE835E8BFEA4D0C0D5CF59AAD3E84AB1F280FEA26E2CB34C94623D1265F4EBD641DCFC378BB4BC423ABDA0AD2E5220CC279ACEA46B29C8B79ABF2604AD70BF1959E7E585B99C79157D3E972DF4696079BC5A3AB2808E364DFB2F5D726955524F17C360D1779DA88BB3DB32A13CED7F60B57C5DF49F55B9D805E83F3397F6E24E54E617D6D65C332558F27F2A1CD2A0EE7AB7C27DFAE2A2BD86DE2681684D1520644251F36CB487C19D50714C5C11F9B5C703B9FCCABAF58994B25FAD1F562365BD43E24735559AC7CEDAA78BB6AF3B779D4A9EF268E20CF67A2F4A4F60B8B3F359E1D3B0ABD06FD57BD89A181E3CFBD84E835C9D9BF09BD06E7339EDC983CC7CEDAD2134F351D44AF41FF556F626830907CF208BD063D379EDC98344DE8D7317A0D7048F526860603C9278FD06BD073A3C98DCD64E2DFAF667A0D70C83F8F2F328C7CF249FDDEF333A0D7E07C46911B8B545E8C1C3C7D4D8ED16B8027EA7F3EF9C6D5ADDC07D16BD0A9FEE786B8057BBE67869A4ED16B8027EA7F3EF9865E83E1EB7F6E4CA6CBE88C0DE274F41AE089FA9F4F7EC9E7B7084F9F62E228F41A74AAFFB9A126C8F1EEAAE1C5349FE8EB2C6BA7D76014FA9F4F7EA9CD6D711EF41A74AAFFB9B149D64BEF5A4D3959CD790646F41A8C42FFF36994E835E814B9D14BF41A8C02F9D44BF41A748ADCE8257A0D4641E4D3A7AE37026DBDA5D7A04BE4462F39CE0D7A0DFCF457F683FEA1EB8D405BD9BFDACB9F5D6F04C68BDCE825C7B941AF819FBE663FE851D71B81967E887CEA7A233062E4461FB9CE0D7A0DFCF453FCA4FFE87A2BD0CE5DF68FF6B6EB8DC088911B7DE43A37E835F0D45B2E00EC9F0F5CDD806E911B3DE43A37E835F0D417065EBD23865D5C368C2E911BFDE33C37E835F0D48FD75C01D8333F5F731A0A1D23377AC77D6ED06BE0ABB528F1775D6F058EF751FC8B7DEF7A2B306EE446DFB8CF0D7A0DBC25CE94BFFEABEBADC0B1E41900AEAE41C7C88D7E39436ED06BE02D71CB26BF28FBE2A7B8F6EFE56B26AF41C7C88D3E394B6ED06BE0AF4F32A0DE7266A307FE7A2DFFB11826A373E4467F9C2737E835F0D74F15502FDF7E597F85C7BE7C8AE43FD4EB75D73F3200B9D11767CB0D7A0D7C96B779F4022364F881DCE813F7B941AF81D77E7CE87AA7C3B13E716D0D3C416EF4C71972835E03CFADDF76BDDFE118D75C5A038F901BFD7096DCA0D7C07B3FD65FAE3FC0631FBFDC71AC069E21377C77B6DCA0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1A0D7000080A1F8FF0160E9E5060A4853AB0000002574455874646174653A63726561746500323031382D30352D32395430383A32393A35332B30303A303073853FF30000002574455874646174653A6D6F6469667900323031382D30352D32395430383A32393A35332B30303A303002D8874F0000000049454E44AE426082>|png>|755px|163px||>>>>>>

  This problem could easily be solved with the following approaches.

  <\itemize>
    <item>Alice could use a new address for every transaction. In our
    example, Alice would create a new address in group <math|j> and transfer
    the rest <math|10> coin to her new address. This is recommended in
    practice due to privacy and security reasons.

    <item>If Alice makes transaction frequently, she might consider creating
    one address for each address group.

    <item>Alice could split the transaction into two transactions: one
    changes her <math|100> coins into <math|90> coins and <math|10> coins,
    one sends <math|90> coins to Bob directly.
  </itemize>

  With these approaches, we could divide all transactions into
  <math|G\<times\>G> shards. Therefore, in our consensus algorithm, there are
  <math|G\<times\>G> chains in total. Each chain takes care of one
  transaction shard. For simplicity, let us use <math|Chain<rsub|i,j>> to
  denote the chain consisting of transactions from <math|G<rsub|i>> to
  <math|G<rsub|j>>. <math|Chain<rsub|i,j>> depends on the transactions in
  <math|Chain<rsub|k,i>> for all <math|k\<in\>G> as a result of the UTXO
  model. For user in group <math|i>, it only needs to download all the data
  for <math|Chain<rsub|j,i>> for all <math|j\<in\>G> and
  <math|Chain<rsub|i,k>> for all <math|k\<in\>G> to know all the related
  transactions. That is <math|2G-1> chains for each user instead of all the
  <math|G\<times\>G> chains. This contributes to the scalability of our
  algorithm because each user only has to process part of the overall network
  data. Blocks in different chains could be committed in parallel to each
  other. This would also make mining more efficient. There are two crucial
  points to make our UTXO model correct.

  <\description>
    <item*|Input/Output Dependency>Every transaction input should come from a
    UTXO. In our case, every transaction in <math|Chain<rsub|i,j>> should
    depend on several UTXOs from <math|Chain<rsub|k,i>> (<math|k\<in\>G>).

    <item*|No Double Spending>Every UTXO should be used in at most one
    transaction. Especially, in our case, it's not allowed that one UTXO from
    group <math|i> is used in both <math|Chain<rsub|i,j>> and
    <math|Chain<rsub|i,k>>.
  </description>

  If we could achieve these two properties for our <math|G\<times\>G> chains,
  then we could create an efficient and scalable ledger.

  <\definition*>
    <dueto|blockflow>A blockflow is <math|G\<times\>G> forks with one fork
    for each <math|Chain<rsub|i,j>> (<math|i,j\<in\>G>) such that these forks
    have correct input/output dependencies and no double spending.
  </definition*>

  We design a novel consensus algorithm for all participants in the network
  to reach agreement on a same blockflow eventually. In our algorithm, each
  block has multiple dependencies. First, like blockchain, each new block in
  <math|Chain<rsub|i,j>> contains a block hash representing a tip of each
  <math|Chain<rsub|i,k>> (<math|k\<in\>G>). Second, each new block in
  <math|Chain<rsub|i,j>> needs to contain a block hash representing one tip
  from one of <math|<around*|{|Chain<rsub|k,l>|}><rsub|l\<in\>G>> for all
  <math|k\<in\>G> and <math|k\<neq\>i>. These block hashes could not be
  arbitrary. They must be chosen in a way to produce valid blockflow. Let us
  introduce some formal notations and then describe the rules. Let
  <math|H<rsub|i,j>> be the hash of a new block in <math|Chain<rsub|i,j>>. We
  assume <math|i\<neq\>j> in the following discussion without loss of
  generality (we leave the case <math|i=j> to the reader). The dependencies
  of <math|H<rsub|i,j>> is <math|d<around*|(|H<rsub|i,j>|)>=<around*|{|H<rprime|'><rsub|i,j>|}>\<cup\><around*|{|H<rsub|i,r>|}><rsub|r\<neq\>j>\<cup\><around*|{|H<rsub|k,l<rsub|k>>|}><rsub|k\<neq\>i>>
  where <math|H<rprime|'><rsub|i,j>> is <math|H<rsub|i,j>>'s previous block
  in <math|Chain<rsub|i,j>>. The total number of dependencies is <math|2G-1>.
  For simplicity, we use <math|H<rsub|i,j>\<rightarrow\>H<rsub|i,j><rprime|'>>,
  <math|H<rsub|i,j>\<rightarrow\>H<rsub|i,r>> and
  <math|H<rsub|i,j>\<rightarrow\>H<rsub|k,l<rsub|k>>> to denote the block
  dependencies. We use <math|H<rsub|1>\<less\>H<rsub|2>> to denote that
  <math|H<rsub|2>> is a hash of a descent block of the block corresponding to
  <math|H<rsub|1>> in the same chain, use
  <math|H<rsub|1>\<leqslant\>H<rsub|2>> to denote that either
  <math|H<rsub|1>\<less\>H<rsub|2><rsub|>> or <math|H<rsub|1>=H<rsub|2>>.
  Assume that <math|H<rsub|k,l<rsub|k>>\<rightarrow\>H<rsub|k,l>>
  (<math|k\<neq\>i,l\<neq\>l<rsub|k>>) by definition. Let
  <math|D<around*|(|H<rsub|i,j>|)>=d<around*|(|H<rsub|i,j>|)>\<cup\><around*|{|H<rsub|k,l>|}><rsub|k\<neq\>i,l\<neq\>l<rsub|k>>>.
  <math|D<around*|(|H<rsub|i,j>|)>> contains one hash from each chain.
  <math|D<around*|(|H<rsub|i,j>|)>> is supposed to decide a blockflow under
  certain conditions. We say <math|D<around*|(|H<rsub|1>|)>\<less\>D<around*|(|H<rsub|2><rsub|>|)>>
  if for all <math|H<rsub|a,b>\<in\>D<around*|(|H<rsub|1>|)>> and
  <math|H<rsup|\<ast\>><rsub|a,b>\<in\>D<around*|(|H<rsub|2>|)>> we have
  <math|H<rsub|a,b>\<less\>H<rsup|\<ast\>><rsub|a,b>>. Let
  <math|Output<around*|(|H|)>> be all the transaction outputs from the chain
  ended with block hash <math|H>. Let <math|Input<around*|(|H|)>> be all the
  UTXOs used as transaction inputs in the chain ended with block hash
  <math|H>. The rules for checking <math|d<around*|(|H<rsub|i,j>|)>> are as
  follows.

  <\description>
    <item*|Admissibility>

    <\enumerate-numeric>
      <item>If <math|H<rsup|\<ast\>><rsub|i,j>\<less\>H<rsub|i,j>> and
      <math|H<rsup|\<ast\>><rsub|i,j>\<rightarrow\>H<rsup|\<ast\>><rsub|i,r>>,
      then <math|H<rsup|\<ast\>><rsub|i,r>\<leqslant\>H<rsub|i,r>>.

      <item>If <math|H<rsup|\<ast\>><rsub|i,j>\<less\>H<rsub|i,j>> and
      <math|H<rsup|\<ast\>><rsub|i,j>\<rightarrow\>H<rsup|\<ast\>><rsub|k,m<rsub|k>>>
      (<math|k\<neq\>i>), then <math|H<rsup|\<ast\>><rsub|k,m<rsub|k>>\<leqslant\>H<rsub|k,m<rsub|k>>>
      where <math|H<rsub|k,m<rsub|k>>\<in\>D<around*|(|H<rsub|i,j>|)>>.

      <item>If <math|H<rsub|i,r>\<rightarrow\>H<rsub|i,l><rsup|\<ast\>>> in
      <math|d<around*|(|H<rsub|i,r>|)>> for <math|r\<neq\>j>, then
      <math|H<rsup|\<ast\>><rsub|i,l>\<leqslant\>H<rsub|i,l>>.

      <item>If <math|H<rsub|i,r>\<rightarrow\>H<rsub|k,m<rsub|k>><rsup|\<ast\>>>
      in <math|d<around*|(|H<rsub|i,r>|)>> for <math|r\<neq\>j,k\<neq\>i>,
      then <math|H<rsup|\<ast\>><rsub|k,m<rsub|k>>\<leqslant\>H<rsub|k,m<rsub|k>>>
      where <math|H<rsub|k,m<rsub|k>>\<in\>D<around*|(|H<rsub|i,j>|)>>.

      <item>If <math|H<rsub|k,l<rsub|k>>\<rightarrow\>H<rsup|\<ast\>><rsub|s,m<rsub|s>>>
      in <math|d<around*|(|H<rsub|k,l<rsub|k>>|)>> for
      <math|k\<neq\>i,s\<neq\>k>, then <math|><math|H<rsup|\<ast\>><rsub|s,m<rsub|s>>\<leqslant\>H<rsub|s,m<rsub|s>>>
      where <math|H<rsub|s,m<rsub|s>>\<in\>D<around*|(|H<rsub|i,j>|)>>.
    </enumerate-numeric>

    <item*|Input/output dependency><math|Input<around*|(|H<rsub|i,j>|)>\<subset\><around*|(|\<cup\><rsub|k\<in\>G>Output<around*|(|H<rsub|k,i>|)>|)>>.

    <item*|No double spending><math|Input<around*|(|H<rsub|i,j>|)>\<cap\>Input<around*|(|H<rsub|i,k>|)>=\<varnothing\>>.
  </description>

  In our algorithm, every node only accepts new blocks that are validated by
  these rules. These rules guarantee that every valid new block implies one
  valid blockflow. Let us prove this important fact.

  <\lemma>
    <math|D*<around*|(|H<rsub|i,j><rprime|'>|)>\<less\>D<around*|(|H<rsub|i,j>|)>>.
  </lemma>

  <\proof>
    We only need to show that <math|D*<around*|(|H<rsub|i,j><rprime|'>|)>\<leqslant\>D<around*|(|H<rsub|i,j>|)>>
    since <math|H<rsub|i,j><rprime|'>\<less\>H<rsub|i,j>>. Let us prove it
    for three different cases.

    <\enumerate-numeric>
      <item>If <math|H<rsub|i,j><rprime|'>\<rightarrow\>H<rsup|\<ast\>><rsub|i,r>>
      in <math|d<around*|(|H<rsub|i,j><rprime|'>|)>>, then
      <math|H<rsup|\<ast\>><rsub|i,r>\<leqslant\>H<rsub|i,r>> by rule
      <math|1> of admissibility checking.

      <item>If <math|H<rprime|'><rsub|i,j>\<rightarrow\>H<rsup|\<ast\>><rsub|k,m<rsub|k>>>
      in <math|d<around*|(|H<rsub|i,j><rprime|'>|)>> for <math|k\<neq\>i>,
      then <math|H<rsup|\<ast\>><rsub|k,m<rsub|k>>\<leqslant\>H<rsub|k,m<rsub|k>>>
      by rule <math|2> of admissibility checking.

      <item>If <math|H<rsup|\<ast\>><rsub|k,m<rsub|k>>\<rightarrow\>H<rsup|\<ast\>><rsub|k,m>>
      in <math|d<around*|(|H<rsup|\<ast\>><rsub|k,m<rsub|k>>|)>> for
      <math|m\<neq\>m<rsub|k>>, then by rule <math|1> of admissibility
      checking and case <math|2> in this proof, we have
      <math|H<rsup|\<ast\>><rsub|k,m>\<leqslant\>H<rsup|\<times\>><rsub|k,m>\<in\>d<around*|(|H<rsub|k,m<rsub|k>>|)>>.
      Again, by rule <math|3> of admissibility checking, we have
      <math|H<rsup|\<ast\>><rsub|k,m>\<leqslant\>H<rsub|k,m><rsup|\<times\>>\<leqslant\>H<rsub|k,m>>.
    </enumerate-numeric>
  </proof>

  <\lemma>
    <math|D<around*|(|H<rsub|i,r>|)>\<less\>D<around*|(|H<rsub|i,j>|)>> for
    <math|r\<neq\>j>.
  </lemma>

  <\proof>
    We only need to show that <math|D<around*|(|H<rsub|i,r>|)>\<leqslant\>D<around*|(|H<rsub|i,j>|)>>
    since <math|H<rsub|i,r><rprime|'>\<less\>H<rsub|i,r>>. Let us prove it by
    induction for three different cases.

    <\enumerate-numeric>
      <item>If <math|H<rsub|i,r>\<rightarrow\>H<rsub|i,l><rsup|\<ast\>>> in
      <math|d<around*|(|H<rsub|i,r>|)>>, then
      <math|><math|H<rsup|\<ast\>><rsub|i,l>\<leqslant\>H<rsub|i,l>> by rule
      <math|3> of admissibility checking.

      <item>If <math|H<rsub|i,r>\<rightarrow\>H<rsub|k,m<rsub|k>><rsup|\<ast\>>>
      in <math|d<around*|(|H<rsub|i,r>|)>> for <math|k\<neq\>i>, then
      <math|H<rsup|\<ast\>><rsub|k,m<rsub|k>>\<leqslant\>H<rsub|k,m<rsub|k>>>
      by rule <math|4> of admissibility checking.

      <item>If <math|H<rsup|\<ast\>><rsub|k,m<rsub|k>>\<rightarrow\>H<rsub|k,m><rsup|\<ast\>>>
      in <math|d<around*|(|H<rsup|\<ast\>><rsub|k,m<rsub|k>>|)>> for
      <math|m\<neq\>m<rsub|k>>, then by rule <math|1> of admissibility
      checking and case 2 in this proof, we have
      <math|H<rsup|\<ast\>><rsub|k,m>\<leqslant\>H<rsup|\<times\>><rsub|k,m>\<in\>d<around*|(|H<rsub|k,m<rsub|k>>|)>>.
      Again, by rule <math|3> of admissibility checking, we have
      <math|H<rsup|\<ast\>><rsub|k,m>\<leqslant\>H<rsub|k,m><rsup|\<times\>>\<leqslant\>H<rsub|k,m>>.
    </enumerate-numeric>
  </proof>

  <\lemma>
    <math|D<around*|(|H<rsub|k,l>|)>\<less\>D<around*|(|H<rsub|i,j>|)>> for
    <math|k\<neq\>i>.
  </lemma>

  <\proof>
    We only need to show that <math|D<around*|(|H<rsub|k,l<rsub|k>>|)>\<less\>D<around*|(|H<rsub|i,j>|)>>
    since we have <math|D<around*|(|H<rsub|k,l>|)>\<less\>D<around*|(|H<rsub|k,l<rsub|k>>|)>>
    for <math|l\<neq\>l<rsub|k>> by Lemma <math|2> and induction. Again, we
    only need to show that <math|D<around*|(|H<rsub|k,l<rsub|k>>|)>\<leqslant\>D<around*|(|H<rsub|i,j>|)>>
    since <math|H<rsub|k,l<rsub|k>><rprime|'>\<less\>H<rsub|k,l<rsub|k>>>.
    Let us prove it<math|> by induction for three different cases.

    <\enumerate-numeric>
      <item>If <math|H<rsub|k,l<rsub|k>>\<rightarrow\>H<rsub|k,l>> in
      <math|d<around*|(|H<rsub|k,l<rsub|k>>|)>> for <math|l\<neq\>l<rsub|k>>,
      then <math|H<rsub|k,l>\<in\>D<around*|(|H<rsub|i,j>|)>> followed from
      the definition of <math|D<around*|(|H<rsub|i,j>|)>>.

      <item>If <math|H<rsub|k,l<rsub|k>>\<rightarrow\>H<rsub|s,m<rsub|s>><rsup|\<ast\>>>
      in <math|d<around*|(|H<rsub|k,l<rsub|k>>|)>> for <math|s\<neq\>k>, then
      <math|H<rsup|\<ast\>><rsub|s,m<rsub|s>>\<leqslant\>H<rsub|s,m<rsub|s>>>
      by rule <math|5> of admissibility checking.

      <item>If <math|H<rsup|\<ast\>><rsub|s,m<rsub|s>>\<rightarrow\>H<rsub|s,m><rsup|\<ast\>>>
      in <math|d<around*|(|H<rsup|\<ast\>><rsub|s,m<rsub|s>>|)>> for
      <math|m\<neq\>m<rsub|s>>, then by rule <math|1> of admissibility
      checking, we have <math|H<rsup|\<ast\>><rsub|s,m>\<leqslant\>H<rsup|\<times\>><rsub|s,m>\<in\>d<around*|(|H<rsub|s,m<rsub|s>>|)>>.
      Again, by rule <math|3> of admissibility checking, we have
      <math|H<rsup|\<ast\>><rsub|s,m>\<leqslant\>H<rsub|s,m><rsup|\<times\>>\<leqslant\>H<rsub|s,m>>.
    </enumerate-numeric>
  </proof>

  <\lemma>
    If <math|H<rsub|i,j>> is the hash of a new valid block satisfying all the
    checking rules, then <math|D<around*|(|H<rsub|i,j>|)>> is a blockflow.
  </lemma>

  <\proof>
    We just need to show that <math|D<around*|(|H<rsub|i,j>|)>> has correct
    input/output dependencies and no double spending. We prove this
    inductively.

    By Lemma <math|1>, Lemma <math|2> and the induction fact that
    <math|D<around*|(|H<rsub|i,k>|)>> is a blockflow for <math|k\<neq\>j>, we
    know <math|Input<around*|(|H<rsub|i,k>|)>\<subset\><around*|(|\<cup\><rsub|k\<in\>G>Output<around*|(|H<rsub|k,i>|)>|)>>.
    For <math|k\<neq\>i>, by Lemma <math|3> and the fact that
    <math|D<around*|(|H<rsub|k,l>|)>> is a blockflow, we know that
    <math|Input<around*|(|H<rsub|k,l>|)>\<subset\><around*|(|\<cup\><rsub|m\<in\>G>Output<around*|(|H<rsub|m,k>|)>|)>>.
    Therefore, input/output dependencies are always kept.

    No double spending is easy to prove. For <math|k\<neq\>i>, since
    <math|D<around*|(|H<rsub|k,l<rsub|k>>|)>> is a blockflow, we have
    <math|Input<around*|(|H<rsub|k,l<rsub|1>>|)>\<cap\>Input<around*|(|H<rsub|k,l<rsub|2>>|)>=\<varnothing\>>
    for all <math|l<rsub|1>,l<rsub|2>>. Together with the no-double-spending
    check for all the inputs of group <math|i>, no double spending is kept
    for all address groups.
  </proof>

  This important lemma shows that a valid new block actually extends one
  previous blockflow. There are two problems left: the existence of valid new
  blocks following all checking rules; and how to choose the best of such
  blocks. The existence is easy since an empty block with trivial
  dependencies satisfies all the rules. The challenge is how to make the
  blockflow include as many blocks and valid transactions as possible. In
  blockchain, the system considers the best chain or best fork and always
  tries to extend that best chain. Similarly, in blockflow, we propose an
  algorithm for users to find the best blockflow and then to extend it.

  <subparagraph|Mining.>Suppose a miner <math|M> wants to mine
  <math|Chain<rsub|i,j>>. <math|M> should have an address in group <math|j>
  to receive coinbase rewards. By the above lemma, each latest block header
  in each <math|Chain<rsub|i,j>> defines a valid blockflow. In order to
  propose a new block, a miner needs to first find valid dependencies
  <math|d<around*|(|H<rsub|i,j>|)>> for <math|Chain<rsub|i,j>> and then to
  calculate a valid mining nonce. Since we exploit PoW for consensus, a miner
  wants to make its block proposed accumulates as much work as possible. In
  general, there are two ways to find a proper
  <math|d<around*|(|H<rsub|i,j>|)>>: heuristic approach and optimization
  approach.

  Let us introduce a new definition to help describe our mining algorithm.
  Let <math|H<rsub|k<rsub|1>,l<rsub|1>>> and
  <math|H<rsub|k<rsub|2>,l<rsub|2>>> be two block hashes. We say that
  blockflow <math|B F<rsub|1>> is compatible with blockflow <math|B
  F<rsub|2>> if <math|<around*|{|H<rsup|1><rsub|m,n>|}><rsub|n\<in\>G>\<less\><around*|{|H<rsub|m,n><rsup|2>|}><rsub|n\<in\>G>>
  or <math|<around*|{|H<rsup|2><rsub|m,n>|}><rsub|n\<in\>G>\<less\><around*|{|H<rsub|m,n><rsup|1>|}><rsub|n\<in\>G>>
  for all <math|m\<in\>G> where <math|H<rsup|1><rsub|m,n>\<in\>B F<rsub|1>>
  and <math|H<rsup|2><rsub|m,n>\<in\>B F<rsub|2>>. If blockflow <math|B
  F<rsub|1>> is compatible with <math|B F<rsub|2>>, we can define the union
  of two blockflows <math|B F<rsub|1>\<cup\>B F<rsub|2>> be the union of each
  <math|Chain<rsub|i,j>>. This concept of compatibility is useful because of
  the following lemma.

  <\lemma>
    If blockflow <math|B F<rsub|1>> is compatible with blockflow <math|B
    F<rsub|2>>, then <math|B F<rsub|1>\<cup\>B F<rsub|2>> is a blockflow.
  </lemma>

  <\proof>
    It's easy to check the input/output dependencies and no double spending
    for <math|B F<rsub|1>\<cup\>B F<rsub|2>>, since <math|B F<rsub|1>\<cup\>B
    F<rsub|2>> is the union of each chain with the proper precondition.
  </proof>

  One simple heuristic approach for resolving dependencies works iteratively
  as follows. Miner <math|M> first selects the best blockflow
  <math|D<around*|(|H<rsub|k<rsub|1>,l<rsub|1>>|)>> so far. Based on this
  initial blockflow, <math|M> then try to find compatible blockflows
  <math|D<around*|(|H<rsub|k<rprime|'>,l<rprime|'>>|)>> for other user group
  <math|k<rprime|'>\<neq\>k<rsub|1>>. <math|M> also needs to find a
  compatible dependencies <math|H<rsub|i,r>> for each <math|r>. The miner
  expands the initial blockflow step by step. The final blockflow <math|B F>
  is the union of all these compatible blockflows. If the new block to be
  mined is of hash <math|H<rsub|i,j>>, then <math|B F> uniquely defines
  <math|d<around*|(|H<rsub|i,j>|)>>. It's very easy to show that
  <math|d<around*|(|H<rsub|i,j>|)>> satisfies all the checking rules using
  Lemma <math|5>. After <math|M> gets <math|B F>, it could start to collect
  valid transactions for <math|B F>. <math|M> puts all valid transactions
  together to create a new block template for mining. This heuristic approach
  could be improved further, e.g. <math|<around*|{|H<rsub|i,r>|}><rsub|r\<in\>G>>
  could be resolved more aggressively using checking rules. We do not want to
  go depth here so as to make the content more compact. The optimization
  approach for resolving dependencies is by modeling the dependencies as an
  optimization problem. Then one could use integer programming for example to
  calculate the best dependencies with best-accumulated PoW work. In general,
  we think that the heuristic approach is faster and usually optimal when
  there are not so many chain forks.

  \ This algorithm is similar to blockchain mining, each miner tries to
  extend the best blockflow. The crucial difference is that our algorithm
  could confirm <math|G\<times\>G> blocks in one new block. Miners could mine
  and commit its block in parallel. Since our algorithm always extends the
  best blockflow, it reaches consensus eventually as do blockchain. Once a
  set of valid dependencies are computed, it determines tips for each chain.
  The mining target would be adjusted based on all the latest blocks decided
  by the dependencies from all chains.

  In practice, a node for group <math|i> could compute the same
  <math|d<around*|(|H<rsub|i,j>|)>> for different group <math|j>, since
  <math|Chain<rsub|i,j>> (<math|j\<in\>G>) shares the same dependencies
  structure. Further, the node for group <math|i> could maintain the state of
  best blockflow and dependencies <math|D<around*|(|H<rsub|i,j>|)>>, and
  update them whenever it receives new blocks and headers. In our mining
  algorithm, we also encode the group information of each block into its
  hash, which brings optimizations for indexing in our reference
  implementation. We could also use digests of hashes for cross-chain
  dependencies to save some storage space.

  Our concrete hash function for mining algorithm would work more or less
  like this. The algorithm first computes the hash string <math|H<rsub|1>> of
  the blocks with a random nonce, then it uses <math|H<rsub|1>> as a random
  number to get a random block hash <math|H<rsub|2>> from history. In the
  last step, it uses <math|H<rsub|2>> as input to compute a final hash
  string. With this mining function, miners have to access CPU, memory, and
  even disk. This is our current design for hash function, but we might
  change it if we find a better alternative.

  <paragraph|Analysis.>With our new BlockFlow algorithm, the TPS could be
  improved dramatically. Let's analysis TPS in a semi-formal way here. Let
  <math|P> be the value of TPS for each chain, <math|S> be the average size
  in KB per transaction, <math|D> be the propagation delay of one block,
  <math|T> be the average mining time, the orphan rate <math|R> could be
  roughly estimated as <math|D/T>. Let <math|B> be the average network
  bandwidth of nodes inside our network, we have the following constraints:

  \;

  <\eqnarray*>
    <tformat|<table|<row|<cell|<frac|D|T>>|<cell|\<leqslant\>>|<cell|R>>|<row|<cell|<around*|(|2G-1|)>\<times\>P\<times\>S\<times\><around*|(|1+<frac|D|T>|)>>|<cell|\<leqslant\>>|<cell|B>>>>
  </eqnarray*>

  On the other hand, we could estimate <math|<frac|D|T>> based on empirical
  observations. We could assume that the propagation delay per KB is <math|d>
  when block size is not too large. Then we have
  <math|D=T\<times\>P\<times\>S\<times\>d> and
  <math|<frac|D|T>=P\<times\>S\<times\>d>. Therefore,

  <\eqnarray*>
    <tformat|<table|<row|<cell|P\<times\>S\<times\>d>|<cell|\<leqslant\>>|<cell|R>>|<row|<cell|<around*|(|2G-1|)>\<times\>P\<times\>S\<times\><around*|(|1+P\<times\>S\<times\>d|)>>|<cell|\<leqslant\>>|<cell|B>>>>
  </eqnarray*>

  If we take <math|G> to be <math|32>, <math|R> to be 6%, <math|B> to be
  <math|10Mb>, S to be <math|0.5>KB, <math|d> to be 8ms (1.5MB broadcast in
  12s), then <math|P> could be 15. The final TPS is
  <math|P\<times\>G\<times\>G=15360> which is greater than <math|10000>.

  As for security, our algorithm suffers from 51% attack instead of 1%
  attack. Thanks to the sophisticated block dependencies, if one wants to
  attack one chain, it has to attack all the other chains as well. All the
  proof-of-work are accumulated into new blocks, so we don't diverse the
  mining work.

  <section|Protocols and Applications><label|sec-exchange>

  We believe that in general it's impossible to scale smart contract to work
  efficiently with sharding algorithms. However, it's possible to scale the
  most useful functionalities while keeping the other functionalities still
  available in a non-scaling setup. In Alephium, we decompose smart contract
  into token part and data part. Both tokens and data are easily scalable,
  but the cost is that we lose some generality. However, we plan to support
  smart contracts in specific shards for the cases where developers really
  need powerful contracts (e.g. turning complete contracts). We will give a
  high-level description of our protocols in plain English. It's in no way to
  be detailed documentation.

  <subsection|Token Protocol>

  In our protocol, we support the creation and removal of customized tokens.
  As we have seen in recent years, tokens are crucial for the adoption of
  blockchain protocols. In our design, we want to make token creation as easy
  as possible, but at the same time, we don't want people to abuse token
  creation leaving many null coins in the system. For each token creation,
  the creator needs to burn a specific number of coins. Also, every
  customized token has an expiry date which depends on how many coins were
  burnt during the creation, in order to further reduce storage and
  computation cost. We category tokens into several classes: convertible
  token, inconvertible token, and mixed token.

  <\description>
    <item*|Inconvertible token>An inconvertible token is just a simple
    digital token got created. It would have very simple meta info.

    <item*|Convertible token>A convertible token is used for the cases where
    the token created could be converted to Aleph (built-in coin)
    automatically.

    <item*|Mixed token>A mixed token is a combination of several convertible
    tokens and inconvertible tokens. The converting ratio could be revealed
    lazily.
  </description>

  In order to create a convertible token, the creator needs to deposit twice
  amount of the converted token value as reserves. For example, if one wants
  to create a new token which would be converted to 1000 Aleph in the future,
  one needs to deposit 2000 Aleph in the beginning. If users buy out this new
  token, the creator still has 1000 Aleph deposit in the system. \ If the
  creator does not operate properly, he will lose all the reserves and all
  the token buyers would get refunded. With this stake-based mechanism, the
  creator would be more likely to operate this token correctly. For a mixed
  token, as there might be several convertible tokens got created, we enforce
  that the converting ratios would sum up to one so that no Aleph coin would
  be created from air. We design a token-level script language for the
  creation and removal of new tokens. Once a token is created, it will follow
  the UTXO model, and users could exchange them. Combining our data model
  with our token-level script language, we could build almost all practical
  applications.

  <subsection|Data Protocol>

  Most of the modern blockchain protocols have a built-in virtual machine for
  general computing. With such VMs, blockchains can implement useful and
  complicated decentralized applications. However, such generality also comes
  with a high cost. All the nodes in the network have to verify all the
  computation, even though the computation might not be relevant to most of
  the nodes. It's also very challenging to scale such virtual machines for
  sharding algorithms.

  In Alephium, we shift from this code-centric approach to a data-centric
  approach. That is, users only submit data to our blockflow network and get
  data stored decentralized. The data submitted could be raw digital data,
  data digest, or code. Most of the nodes in the network do not need to know
  the real meaning of the data. Only the users that are related to the data
  could use specific applications to play with the specific data. By this
  design, we could achieve both decentralization and computing scalability.
  In some sense, our philosophy is very similar to the philosophy of TCP/IP
  protocol. We provide a very low-level infrastructure for decentralizing
  data. The application layer would take care of the usage of data. The
  wisdom of Lisp indicates that data is the same as program, so we don't lose
  any generality. On the other hand, using data instead of program allows
  high-level applications to design and upgrade their own domain-specific
  languages, which could reduce the security risks of our system. The other
  benefit of this data-centric approach is that it could be easily integrated
  with UTXO model. We believe that developers could build efficient and
  scalable DAPPs by combining our token protocol and data protocol in a smart
  way.

  <subsection|Smart Contract>

  Note that in our sharding algorithm we have <math|G> specific shards which
  are intra-group shards consisting of transactions from group <math|i> to
  group <math|i>. Each of these intra-group shards is no different from a
  traditional blockchain. We plan to design a VM language for these specific
  shards so that we could build complicated applications. Since we have
  <math|G> such special shards, our system could support more smart contracts
  compared to a single blockchain. Combining smart contract with our scalable
  token protocol, developers could build efficient and powerful dApps.

  <subsection|Features>

  With our new consensus algorithm and protocols, we could achieve
  scalability for both data and computation. We introduce several useful
  features in this section to make our system even more practical and
  sustainable.

  <\description-paragraphs>
    <item*|Mining Rewards Lockup>In Alephium, miners could choose optionally
    to lockup their coinbase rewards for a certain period. There will be some
    base coinbase rewards for each newly mined block. Furthermore, there will
    be extra rewards that are proportional to the lockup period. We want to
    incentive miners to keep their mining rewards for long term interests
    instead of cashing out immediately.
  </description-paragraphs>

  <paragraph|Multisignature>For all the data submitted and token exchanges in
  our protocol, there could be multiple owners and multiple signatures. It
  could be used for security reason, but it could also be used to represent
  ownership. Although each chain involves at most two user groups to
  participate in, it's not really a problem to support multiple signatures in
  general. Users could create new accounts in specific address group easily.

  <paragraph|Expiry Date>All the data and customized token have an expiry
  date which could be represented as timestamp or block heights. If data got
  expired, then the network does not need to store it anymore and could
  remove it from history. If a customized token expired, it would either get
  discarded if it's not convertible or got converted automatically otherwise.
  Expiration date provides limited functionality of garbage collection.

  <paragraph|Lock Time>An UTXO could be locked by setting a lock time for it.
  We make lock time as a built-in feature for UTXOs because it's useful in
  many real scenarios.

  <paragraph|Pricing Model>The whole PoW network is a game between users,
  miners, and protocol. In order to keep this game in a good shape, it's
  crucial to design a reasonable economic model for it. In our case, it's
  about how to price transactions and data. It's relatively simple, as we
  don't need to price computation. Therefore, we could consider simply the
  size and the expiry date of the transactions and data submitted. For
  transactions, we also price each input based on how long the tokens/coins
  have been stored in order to reduce the number of small UTXOs.

  <subsection|Applications>

  All the classical dApps in Bitcoin and Ethereum platforms could be migrated
  to Alephium platform without major changes given our native cross-shard
  transaction support. Besides that, we could enable a new type of
  high-throughput applications. The workflow of this type of application
  using our platform would be like this:

  <\enumerate-numeric>
    <item>The developers develop a decentralized application (usually should
    be open sourced) and publish it on the internet. The project owner
    creates a token for the project and publishes the digital digest of the
    application to Alephium platform (We might implement a decentralized
    application market for Alephium).

    <item>Users download the application from internet and verify the digest
    of the application. Then users run this application on the top of
    Alephium platform.

    <item>All the data and transactions generated by this application would
    be stored in the P2P network. <strong|Nodes that do not use this
    application would not need to verify the content of the data.>
  </enumerate-numeric>

  In this approach, the application is still reversion resistant with a
  single unchanging application history, but the applications will not use
  the network to do all the computation.

  In some scenarios, the application could be semi-decentralized if
  decentralization could be traded off for performance. For example, the
  project could have a centralized service to interact with all its users.
  However, all the transactions the application made would be published to
  Alephium network, so that all the users could check by downloading all the
  relevant application data.

  <section|System><label|sec-alephium>

  In this section, we give a high-level description of some of the key parts
  of our system. We will not go deep into details which should be covered in
  the reference implementation.

  <subsection|Network>

  The Alephium network consists of nodes for different address groups. Nodes
  from different groups need to be connected so that blocks for
  <math|Chain<rsub|i,j>> would be propagated to both group <math|i> and group
  <math|j>. We design a variant of Kademlia protocol for network discovery.
  Each node keeps a local table of the currently active nodes in the network
  along with necessary meta information (e.g. group id). Nodes in the network
  could update their table regularly by scanning the network. The
  communication protocol we use is very similar to the Kademlia protocol. The
  main difference is that we use hamming distance instead of xor metric to
  computing the distance of two nodes. The reason we made this change is that
  with xor metric nodes with addresses starting with <math|0> are less likely
  to be connected to nodes with address starting with <math|1>.

  <subsection|Nodes>

  With blockflow algorithm, each node stores only part of the
  transaction/data history. For the sake of reliability and security, a
  \Pfull node\Q in our network would run a cluster of <math|G> nodes with one
  node for each address group. All the other services of this cluster could
  access these <math|G> nodes through RPC calls. When initializing connection
  with other nodes or clusters, this cluster will send its network topology
  so that the other nodes could propagate blocks more efficiently.

  In practice, a light client that handles transaction/data only related to a
  very small number of addresses is very useful. In our network, we could
  implement light client similar to Bitcoin by using Bloom filters. Since a
  light client actually downloads history for very few addresses, it could
  deal with transactions/data from different groups in a single node, unlike
  full nodes.

  Note that we could start with a small G when there are not enough
  participants and full nodes. The system would gradually increase G along
  with time. In practice, we could set up G to be high in the beginning, but
  the number of groups that are actually used internally would upgrade from
  small to larger.

  <subsection|Application Layer>

  The core protocol of our network provides a very low-level infrastructure,
  not suited for high-level applications design. To bridge the low-level part
  and high-level application, our system provides official APIs for accessing
  transactions and data. We also plan to provide an application market for
  developers to publish their applications. As we mentioned early that users
  only need to use high-level applications that are related to them.
  Application market would provide a convenient way for users to fetch useful
  applications. This application market could store useful meta information
  about applications in a decentralized way using Kademlia protocol. For the
  application itself, it could be distributed either in a decentralized or
  centralized fashion depending on the requirements.

  <section|Further research><label|sec-conclusion>

  In the following, we describe several research directions that would help
  to improve our system.

  <paragraph|Privacy>For our data protocol, it would be relatively easy to
  enforce privacy by applications. However, in our current design, all the
  transactions are always transparent which might cause potential problems
  for some business.

  <paragraph|Stateless client>Every node in our system stores the entire UTXO
  set for verifying the incoming transactions like Bitcoin. There are
  potential ways to alleviate the need for such full state. The stateless
  client concept uses an additional data structure (e.g. Merkle tree, dynamic
  accumulators) for transaction membership proofs. The network updates and
  maintains the proofs for new blocks. Nodes in the network could validate a
  transaction without the entire UTXO set. Existing stateless technologies
  are not practical enough for our system by the time of writing.

  <paragraph|PoW Improvements/Alternatives>Though the robustness of PoW has
  been proved by time, it's heavily criticized due to its energy consumption.
  However, by the time of writing, we did not really find mature PoW
  alternatives for our platform. Further researches might alleviate the
  energy consumption issue of PoW. As mentioned early, our algorithm actually
  could work with any finality algorithm for blockchain. If there is any PoW
  alternative suitable for our algorithm in the future, it's not difficult to
  replace PoW in our protocol.

  <section|Acknowledgment>

  The author thanks Alos Cochard for reviewing the draft version of this
  paper.

  <\bibliography|bib|tm-plain|/Users/chengwang/Code/scala/alephium-white-paper/white-paper.bib>
    <\bib-list|3>
      <bibitem*|1><label|bib-buterin2014next>Vitalik Buterin
      et<nbsp>al.<newblock> A next-generation smart contract and
      decentralized application platform.<newblock>
      <with|font-shape|italic|White paper>, 2014.<newblock>

      <bibitem*|2><label|bib-nakamoto2008bitcoin>Satoshi Nakamoto.<newblock>
      Bitcoin: a peer-to-peer electronic cash system.<newblock>
      2008.<newblock>

      <bibitem*|3><label|bib-popov2018tangle>S Popov.<newblock> The tangle,
      iota whitepaper.<newblock> 2018.<newblock>
    </bib-list>
  </bibliography>
</body>

<\references>
  <\collection>
    <associate|auto-1|<tuple|1|1>>
    <associate|auto-10|<tuple|3.4|8>>
    <associate|auto-11|<tuple|2|8>>
    <associate|auto-12|<tuple|3|8>>
    <associate|auto-13|<tuple|4|8>>
    <associate|auto-14|<tuple|5|8>>
    <associate|auto-15|<tuple|3.5|8>>
    <associate|auto-16|<tuple|4|8>>
    <associate|auto-17|<tuple|4.1|9>>
    <associate|auto-18|<tuple|4.2|9>>
    <associate|auto-19|<tuple|4.3|9>>
    <associate|auto-2|<tuple|2|2>>
    <associate|auto-20|<tuple|5|9>>
    <associate|auto-21|<tuple|6|9>>
    <associate|auto-22|<tuple|7|10>>
    <associate|auto-23|<tuple|8|10>>
    <associate|auto-24|<tuple|6|10>>
    <associate|auto-25|<tuple|6|10>>
    <associate|auto-26|<tuple|6|10>>
    <associate|auto-3|<tuple|1|2>>
    <associate|auto-4|<tuple|2|5>>
    <associate|auto-5|<tuple|1|6>>
    <associate|auto-6|<tuple|3|6>>
    <associate|auto-7|<tuple|3.1|6>>
    <associate|auto-8|<tuple|3.2|7>>
    <associate|auto-9|<tuple|3.3|7>>
    <associate|bib-buterin2014next|<tuple|1|10>>
    <associate|bib-nakamoto2008bitcoin|<tuple|2|10>>
    <associate|bib-popov2018tangle|<tuple|3|10>>
    <associate|sec-alephium|<tuple|4|9>>
    <associate|sec-blockflow|<tuple|2|2>>
    <associate|sec-conclusion|<tuple|5|9>>
    <associate|sec-exchange|<tuple|3|6>>
    <associate|sec-intro|<tuple|1|1>>
  </collection>
</references>

<\auxiliary>
  <\collection>
    <\associate|bib>
      nakamoto2008bitcoin

      buterin2014next

      popov2018tangle
    </associate>
    <\associate|toc>
      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|1<space|2spc>Introduction>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-1><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|2<space|2spc>Blockflow>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-2><vspace|0.5fn>

      Scalable UTXO model. <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-3><vspace|0.15fn>

      Mining. <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-4><vspace|0.15fn>

      <with|par-left|<quote|4tab>|Analysis.
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-5><vspace|0.15fn>>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|3<space|2spc>Protocols
      and Applications> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-6><vspace|0.5fn>

      <with|par-left|<quote|1tab>|3.1<space|2spc>Token Protocol
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-7>>

      <with|par-left|<quote|1tab>|3.2<space|2spc>Data Protocol
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-8>>

      <with|par-left|<quote|1tab>|3.3<space|2spc>Confidential Transaction
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-9>>

      <with|par-left|<quote|1tab>|3.4<space|2spc>Smart Contract
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-10>>

      <with|par-left|<quote|1tab>|3.5<space|2spc>Features
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-11>>

      <with|par-left|<quote|4tab>|Multisignature
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-12><vspace|0.15fn>>

      <with|par-left|<quote|4tab>|Expiry Date
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-13><vspace|0.15fn>>

      <with|par-left|<quote|4tab>|Lock Time
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-14><vspace|0.15fn>>

      <with|par-left|<quote|4tab>|Pricing model
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-15><vspace|0.15fn>>

      <with|par-left|<quote|1tab>|3.6<space|2spc>Applications
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-16>>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|4<space|2spc>System>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-17><vspace|0.5fn>

      <with|par-left|<quote|1tab>|4.1<space|2spc>Network
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-18>>

      <with|par-left|<quote|1tab>|4.2<space|2spc>Nodes
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-19>>

      <with|par-left|<quote|1tab>|4.3<space|2spc>Application Layer
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-20>>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|5<space|2spc>Further
      research> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-21><vspace|0.5fn>

      <with|par-left|<quote|4tab>|Privacy
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-22><vspace|0.15fn>>

      <with|par-left|<quote|4tab>|Stateless client
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-23><vspace|0.15fn>>

      <with|par-left|<quote|4tab>|PoW Improvements/Alternatives
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-24><vspace|0.15fn>>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|6<space|2spc>Acknowledgment>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-25><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Bibliography>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-26><vspace|0.5fn>
    </associate>
  </collection>
</auxiliary>